package modchu.lib;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.util.Enumeration;import java.util.HashMap;import java.util.LinkedList;import java.util.List;import java.util.Set;import java.util.zip.ZipEntry;import java.util.zip.ZipFile;import javax.imageio.ImageIO;public class Modchu_ModResourcePackMaster extends Modchu_IResourcePackMasterBasis {	protected final Class resourceClass;	protected final File resourceFile;	protected List resourceList;	private ZipFile zipFile;	public Modchu_ModResourcePackMaster(HashMap<String, Object> map) {		super(map);		resourceClass = map.containsKey("Class1") ? (Class) map.get("Class1") : null;		resourceFile = map.containsKey("File") ? (File) map.get("File") : null;		Modchu_Debug.mDebug("Modchu_ModResourcePackMaster init resourceFile="+resourceFile);		if (resourceFile != null); else return;		resourceList = new LinkedList();		try {			zipFile = new ZipFile(resourceFile);			ZipEntry entry = null;			for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {				entry = e.nextElement();				if (entry.isDirectory()) continue;				String entryName = decodeEntryName(entry.getName());				resourceList.add(entryName);				Modchu_Debug.mDebug("Modchu_ModResourcePackMaster init resourceList.add entryName="+entryName);			}		} catch (Exception e) {			e.printStackTrace();		}	}	@Override	public InputStream getInputStream(Object resourceLocation) {		boolean debug = false;		//if (debug) Modchu_Debug.mDebug("Modchu_ModResourcePackMaster getInputStream resourceLocation="+resourceLocation);		String path = getPasth(resourceLocation);		//if (debug) Modchu_Debug.mDebug1("Modchu_ModResourcePackMaster getInputStream path="+path);		if (resourceClass != null) {			//if (debug) Modchu_Debug.mDebug1("Modchu_ModResourcePackMaster getInputStream resourceClass != null resourceClass="+resourceClass);			return resourceClass.getResourceAsStream(path);		}		if (!resourceList.contains(path)) {			//if (debug) Modchu_Debug.mDebug1("Modchu_ModResourcePackMaster getInputStream !resourceList.contains path="+path);			return null;		}		Modchu_Debug.mDebug1("Modchu_ModResourcePackMaster getInputStream resourceList.contains path="+path);		try {			ZipEntry entry = null;			for (Enumeration<? extends ZipEntry> e = zipFile.entries(); e.hasMoreElements();) {				entry = e.nextElement();				if (entry.isDirectory()) continue;				String entryName = decodeEntryName(entry.getName());				if (debug) Modchu_Debug.mDebug("Modchu_ModResourcePackMaster getInputStream entryName="+entryName);				if (entryName.equals(path)) {					InputStream is = zipFile.getInputStream(entry);					//BufferedImage bufferedImage = readBufferedImage(is);					//Modchu_Debug.mDebug("Modchu_ModResourcePackMaster getInputStream BufferedImage="+bufferedImage);					if (debug) Modchu_Debug.mDebug("Modchu_ModResourcePackMaster getInputStream return is="+is);					return is;				}			}		} catch (Exception e) {			e.printStackTrace();		}		if (debug) Modchu_Debug.mDebug("Modchu_ModResourcePackMaster getInputStream return null !! path="+path);		return null;	}/*	public static BufferedImage readBufferedImage(InputStream imageStream) throws IOException {		BufferedImage bufferedimage;		try {			bufferedimage = ImageIO.read(imageStream);		} finally {			IOUtils.closeQuietly(imageStream);		}		return bufferedimage;	}*/	@Override	public boolean resourceExists(Object resourceLocation) {		return resourceClass != null ? getInputStream(resourceLocation) != null :			resourceList.contains(getPasth(resourceLocation));	}	@Override	public Set getResourceDomains() {		return (Set) Modchu_AS.get("DefaultResourcePack", "defaultResourceDomains");	}	@Override	public Object getPackMetadata(Object metadataSerializer, String s) {		return Modchu_AS.get(Modchu_Main.getMinecraftVersion() > 169 ? "IMetadataSerializer" : "MetadataSerializer", "parseMetadataSection", new Class[]{ String.class, Modchu_Reflect.loadClass("com.google.gson.JsonObject") }, metadataSerializer, new Object[]{ s, Modchu_Reflect.newInstance("com.google.gson.JsonObject") });	}	@Override	public BufferedImage getPackImage() {		try {			String name = 					"/" + (Modchu_AS.get(Modchu_AS.resourceLocationGetResourcePath, Modchu_Main.newResourceLocation("pack.png")));			InputStream inputStream = null;			if (resourceClass != null) {				inputStream = resourceClass.getResourceAsStream(name);			} else {				Object resourceLocation = Modchu_AS.get(Modchu_AS.newResourceLocation, "pack.png");				inputStream = getInputStream(resourceLocation);			}			if (inputStream != null) return ImageIO.read(inputStream);		} catch (IOException e) {			e.printStackTrace();		}		return null;	}	@Override	public String getPackName() {		return resourceClass != null ? resourceClass.getSimpleName() : resourceFile.getName();	}	private String getPasth(Object resourceLocation) {		return "" + Modchu_AS.getString(Modchu_AS.resourceLocationGetResourcePath, resourceLocation);	}	private String encodeEntryName(String s) {		String s1 = "assets/";		int i1 = s.indexOf(s1);		if (i1 > -1) {			s = s.substring(i1 + s1.length());			i1 = s.indexOf("/");			if (i1 > -1) {				s = s.substring(i1 + 1);			}		}		return s;	}	private String decodeEntryName(String s) {		String s1 = ":";		int i1 = s.indexOf(s1);		if (i1 > -1) {			s = new StringBuilder().append("assets/").append(s.substring(0, i1)).append("/").append(s.substring(i1 + 1)).toString();		}		return s;	}}