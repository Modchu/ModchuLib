package modchu.lib;import java.util.HashMap;public class Modchu_ModelPlateMaster extends Modchu_ModelBoxMaster {	// 互換用パラメーター	@Deprecated	public static final int planeXY		= 0;	@Deprecated	public static final int planeZY		= 1;	@Deprecated	public static final int planeXZ		= 2;	@Deprecated	public static final int planeXYInv	= 4;	@Deprecated	public static final int planeZYInv	= 5;	@Deprecated	public static final int planeXZInv	= 6;	/*	 * こちらを使用して下さい。	 * ボックスを作った時と同じマッピングになるように調整してます。	 * マッピング的に左右の面は自力で移動しなければ反転されません、前後が逆になります。	 */	public static final int planeXYFront	= 0x10;	public static final int planeXYBack		= 0x14;	public static final int planeZYRight	= 0x11;	public static final int planeZYLeft		= 0x15;	public static final int planeXZTop		= 0x12;	public static final int planeXZBottom	= 0x16;	/**	 * @param pMRenderer	 * @param pArg	 * textureX, textureY, posX, posY, posZ, width, height, facePlane, sizeAdjust	 */	public Modchu_ModelPlateMaster(HashMap<String, Object> map) {		super(null);		if (map != null				&& !map.isEmpty()); else return;		base = map.containsKey("base") ? (Modchu_IModelBox)map.get("base") : null;		boxSizeX = map.containsKey("Integer2") ? (Integer)map.get("Integer2") : 0;		boxSizeY = map.containsKey("Integer3") ? (Integer)map.get("Integer3") : 0;		boxSizeZ = map.containsKey("Integer4") ? (Integer)map.get("Integer4") : 0;		init(map.get("Object"), (Integer)map.get("Integer"), (Integer)map.get("Integer1"),				(Float)map.get("Float"), (Float)map.get("Float1"), (Float)map.get("Float2"),				(Integer)map.get("Integer2"), (Integer)map.get("Integer3"), (Integer)map.get("Integer4"),				(Float)map.get("Float3"));		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster init end.");	}	private void init(Object modelRenderer, int pTextureX, int pTextureY,			float pX, float pY, float pZ, int pWidth, int pHeight, int pPlane, float pZoom) {		modelRenderer = Modchu_Main.getModchuCharacteristicObjectMaster(modelRenderer);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster modelRenderer="+modelRenderer);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster pTexX="+pTextureX+" pTexY="+pTextureY);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster pX="+pX+" pY="+pY+" pZ="+pZ);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster pWidth="+pWidth+" pHeight="+pHeight+" pPlane="+pPlane);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster pZoom="+pZoom);		float lx;		float ly;		float lz;		boolean lotherplane = (pPlane & 0x04) > 0;		int lPlane = pPlane & 0x03;		// i1 は平面の生成位置		switch (lPlane) {		case planeXY:			// xy			posX1 = pX;			posY1 = pY;			posZ1 = pZ;			posX2 = lx = pX + pWidth;			posY2 = ly = pY + pHeight;			posZ2 = lz = pZ;			pX -= pZoom;			pY -= pZoom;			lx += pZoom;			ly += pZoom;			if (lotherplane) {				pZ += pZoom;				lz += pZoom;			} else {				pZ -= pZoom;				lz -= pZoom;			}			break;		case planeZY:			// zy			posX1 = pX;			posY1 = pY;			posZ1 = pZ;			posX2 = lx = pX;			posY2 = ly = pY + pHeight;			posZ2 = lz = pZ + pWidth;			pY -= pZoom;			pZ -= pZoom;			ly += pZoom;			lz += pZoom;			if (lotherplane) {				pX += pZoom;				lx += pZoom;			} else {				pX -= pZoom;				lx -= pZoom;			}			break;		case planeXZ:		default:			// xz			posX1 = pX;			posY1 = pY;			posZ1 = pZ;			posX2 = lx = pX + pWidth;			posY2 = ly = pY;			posZ2 = lz = pZ + pHeight;			pX -= pZoom;			pZ -= pZoom;			lx += pZoom;			lz += pZoom;			if (lotherplane) {				pY += pZoom;				ly += pZoom;			} else {				pY -= pZoom;				ly -= pZoom;			}			break;		}		quadList = new Modchu_TexturedQuad[1];		// 面の法面を反転する		boolean mirror = Modchu_CastHelper.Boolean(Modchu_Reflect.getFieldObject(modelRenderer.getClass(), "mirror", modelRenderer));		if (mirror) {			if (lPlane == 0) {				// xy				float f7 = lx;				lx = pX;				pX = f7;			} else if (lPlane == 1) {				// zy				float f7 = lz;				lz = pZ;				pZ = f7;			} else {				// xz				float f7 = lx;				lx = pX;				pX = f7;			}		}		vertexPositions = Modchu_Reflect.newInstanceArray("PositionTextureVertex", 4);		Object[] o1;		Object[] o2;		Object[] o3;		Object[] o4;		switch (pPlane) {		case planeXYFront:		case planeZYRight:			o1 = new Object[]{ pX, pY, lz, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY) };			o2 = new Object[]{ pX, ly, lz, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY + pHeight) };			o3 = new Object[]{ lx, ly, pZ, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY + pHeight) };			o4 = new Object[]{ lx, pY, pZ, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY) };			lotherplane = false;			break;		case planeXYBack:		case planeZYLeft:			o1 = new Object[]{ lx, pY, pZ, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY) };			o2 = new Object[]{ lx, ly, pZ, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY + pHeight) };			o3 = new Object[]{ pX, ly, lz, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY + pHeight) };			o4 = new Object[]{ pX, pY, lz, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY) };			lotherplane = false;			break;		case planeXZTop:			o1 = new Object[]{ pX, pY, lz, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY) };			o2 = new Object[]{ pX, ly, pZ, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY + pHeight) };			o3 = new Object[]{ lx, ly, pZ, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY + pHeight) };			o4 = new Object[]{ lx, pY, lz, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY) };			lotherplane = false;			break;		case planeXZBottom:			o1 = new Object[]{ lx, pY, lz, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY) };			o2 = new Object[]{ lx, ly, pZ, getU(modelRenderer, pTextureX + pWidth), getV(modelRenderer, pTextureY + pHeight) };			o3 = new Object[]{ pX, ly, pZ, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY + pHeight) };			o4 = new Object[]{ pX, pY, lz, getU(modelRenderer, pTextureX), getV(modelRenderer, pTextureY) };			lotherplane = false;			break;		case planeXY:		case planeZY:		case planeXZ:		case planeXYInv:		case planeZYInv:		case planeXZInv:		default:			o1 = new Object[]{ pX, pY, pZ, 0.0F, 0.0F };			o2 = new Object[]{ lx, pY, lz, 0.0F, 8F };			o3 = new Object[]{ lx, ly, lz, 8F, 8F };			o4 = new Object[]{ pX, ly, pZ, 8F, 0.0F };			break;		}		vertexPositions[0] = newPositionTextureVertex(o1);		vertexPositions[1] = newPositionTextureVertex(o2);		vertexPositions[2] = newPositionTextureVertex(o3);		vertexPositions[3] = newPositionTextureVertex(o4);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster vertexPositions[0]="+vertexPositions[0]);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster vertexPositions[1]="+vertexPositions[1]);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster vertexPositions[2]="+vertexPositions[2]);		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster vertexPositions[3]="+vertexPositions[3]);		Object[] o = Modchu_Reflect.newInstanceArray("PositionTextureVertex", 4);		float textureWidth = Modchu_CastHelper.Float(Modchu_Reflect.invokeMethod(modelRenderer.getClass(), "getTextureWidth", modelRenderer));		float textureHeight = Modchu_CastHelper.Float(Modchu_Reflect.invokeMethod(modelRenderer.getClass(), "getTextureHeight", modelRenderer));		if ((pPlane & 0x0010) > 0) {			o[0] = vertexPositions[0];			o[1] = vertexPositions[1];			o[2] = vertexPositions[2];			o[3] = vertexPositions[3];			quadList[0] = newModchu_TexturedQuad(Modchu_TexturedQuadMaster.class, o);			if (mirror) {				flipFace(quadList[0]);			}		} else {			if (lotherplane) {				// 逆周り				o[0] = vertexPositions[0];				o[1] = vertexPositions[1];				o[2] = vertexPositions[2];				o[3] = vertexPositions[3];			} else {				o[0] = vertexPositions[1];				o[1] = vertexPositions[0];				o[2] = vertexPositions[3];				o[3] = vertexPositions[2];			}			quadList[0] = newModchu_TexturedQuad(Modchu_TexturedQuadMaster.class,  o,					pTextureX, pTextureY, pTextureX + pWidth, pTextureY + pHeight,					textureWidth,					textureHeight);		}		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster quadList[0]="+quadList[0]);	}	public float getU(Object modelRenderer, int pU) {		float textureWidth = Modchu_CastHelper.Float(Modchu_Reflect.invokeMethod(modelRenderer.getClass(), "getTextureWidth", modelRenderer));		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster getU textureWidth="+textureWidth);		float lf = pU / textureWidth;		return lf;	}	public float getV(Object modelRenderer, int pV) {		float textureHeight = Modchu_CastHelper.Float(Modchu_Reflect.invokeMethod(modelRenderer.getClass(), "getTextureHeight", modelRenderer));		//Modchu_Debug.mDebug("Modchu_ModelPlateMaster getV textureHeight="+textureHeight);		float lf = pV / textureHeight;		return lf;	}}