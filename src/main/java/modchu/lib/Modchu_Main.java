package modchu.lib;import java.io.File;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map.Entry;import java.util.concurrent.ConcurrentHashMap;import modchu.lib.characteristic.Modchu_AS;import modchu.lib.characteristic.Modchu_CastHelper;import modchu.lib.characteristic.Modchu_Version;import modchu.model.replacepoint.ModchuModel_FileManagerReplacePoint;import net.minecraft.client.settings.KeyBinding;import net.minecraft.src.mod_Modchu_ModchuLib;import net.minecraftforge.event.world.WorldEvent.Load;public class Modchu_Main {	public static final String version = "8";	//cfg書き込み項目	public static boolean versionCheck = true;	public static final String modName = "ModchuLib";	public static final String versionString = ""+ Modchu_Version.version + "-" + version;	public static ConcurrentHashMap<String, Class> modClassMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Object> modInstanceMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Object, Object[]> eventKeyBindingObjectMap = new ConcurrentHashMap();	public static List<File> modFileList = new ArrayList();	private static ArrayList eventObjectList = new ArrayList();	private static ArrayList eventKeyBindingList = new ArrayList();	private static ArrayList<String> eventObjectLoadCheckList = new ArrayList();	public static Modchu_Main modchu_Main;	public static mod_Modchu_ModchuLib baseModInstance;	public static Class itemRendererClass;	public static Object mc;	public static String newVersion = "";	public static String packageName;	public static String runtimeExceptionString;	private static File cfgdir;	private static File mainCfgfile;	private static File modsDir;	public static final int modchuLibVersion = Modchu_Version.version;	public static int mmmLibVersion;	public static int initModsLoadedCount;	public static boolean isServer = false;	public static boolean isForge = false;	public static boolean isPFLM = false;	public static boolean isItemRendererHD = false;	public static boolean isHD = false;	public static boolean newRelease = false;	public static boolean oldRenderItems = false;	public static boolean runtimeExceptionFlag = false;	public static boolean initModsLoadedFlag = false;	public static boolean isRelease = true;	private static boolean isItemRendererDebug = false;	private static boolean packageNameNull = false;	private static boolean isRemote = false;	static{		String s = System.getenv("modchu");		if ((s != null				&& s.equals("on"))) {			isRelease = false;		}	}	public Modchu_Main() {		modchu_Main = this;	}	public static String getName() {		return modName;	}	public static String getVersion() {		return versionString;	}	public static void load() {		Modchu_AS.instanceCheck();		//対応MOD導入チェック class直チェック		String className1[] = {				"FMLRenderAccessLibrary", "net.minecraft.src.FMLRenderAccessLibrary", "ItemRendererHD"		};		String test2 = null;		for(int n = 0 ; n < className1.length ; n++){			try {				test2 = className1[n];				test2 = ""+Class.forName(test2);				Modchu_Debug.lDebug(test2 + " Check ok.");				if(n == 0						| n == 1) isForge = true;				if(n == 2) isItemRendererHD = true;			} catch (ClassNotFoundException e) {			}		}		if (!isItemRendererHD) {			Modchu_Debug.lDebug("No ItemRendererHD.");		}		if (isItemRendererHD) {			Object b = Modchu_Reflect.getFieldObject("ItemRendererHD", "debug");			if (b != null					&& (Boolean) b) {				isItemRendererDebug = true;			}		}		isHD = isItemRendererHD				&& !isItemRendererDebug;		itemRendererClass = isHD ? Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRendererHD") : Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRenderer");		getPackageInit();		Modchu_Reflect.initNameMap();		File mcDataDir = Modchu_AS.getFile(Modchu_AS.minecraftMcDataDir);		cfgdir = new File(mcDataDir, "/config/");		mainCfgfile = new File(cfgdir, ("Modchu_ModchuLib.cfg"));		modsDir = new File(mcDataDir, "/mods/");		loadcfg();		Modchu_Debug.systemDebug("Modchu_Main load", 1);		//Modchu_Debug.lDebug("Modchu_Main load() getPackageInit");		Modchu_Debug.lDebug("Modchu_Main load() mcDataDir.getAbsolutePath()="+mcDataDir.getAbsolutePath());		String s = mcDataDir.getAbsolutePath();		if (s.indexOf("jars") != -1				| new File(s, "gradle").exists()				| new File(new File(s, "../"), "gradle").exists()) {			isRelease = false;		}		//Modchu_Debug.lDebug("Modchu_Main load() new File= "+(new File(new File(s, "../"), "gradle")));		Modchu_Debug.lDebug("Modchu_Main load() isRelease = "+isRelease);		Class mod_MMM_MMMLib = Modchu_Reflect.loadClass("mod_MMM_MMMLib");		if (mod_MMM_MMMLib != null) {			s = (String) Modchu_Reflect.getFieldObject(mod_MMM_MMMLib, "Revision");			int i = getVersionStringConversionInt(s);			mmmLibVersion = i;		} else {			mmmLibVersion = -1;		}		if (Modchu_Debug.debugMessage				&& !Modchu_Main.isRelease()) Modchu_Debug.debugString = new String[10];		ModchuModel_FileManagerReplacePoint.init();		Modchu_FileManager.getModFile(modsDir, modFileList, modClassMap, "modc_");		Modchu_FileManager.addResourcesMod(modchu_Main.getClass(), modClassMap, "modc_");		registerMods();		String key = "net.minecraft.src.modc_PFLM_PlayerFormLittleMaid";		if (modClassMap.containsKey(key)) {			isPFLM = getModEnabled(modInstanceMap.get(key));		}		if (versionCheck) startVersionCheckThread();	}	public static void modsLoaded() {		Modchu_Debug.lDebug("Modchu_Main modsLoaded()");		baseModInstance.loadCheckThread = null;		if (modInstanceMap.isEmpty()) return;		for (Iterator iterator = modInstanceMap.values().iterator(); iterator.hasNext();) {			Object o = iterator.next();			Class c = o.getClass();			if (getModEnabled(o)) Modchu_Reflect.invokeMethod(c, "modsLoaded", o, -1);		}	}	private static void registerMods() {		if (modClassMap != null				&& !modClassMap.isEmpty()) ;else {			Modchu_Debug.Debug("Modchu_Main registerMods() modClassMap.isEmpty()");			return;		}		ArrayList<String> deleteList = new ArrayList();		Iterator<Class> iterator2 = modClassMap.values().iterator();		for (Iterator<String> iterator = modClassMap.keySet().iterator(); iterator.hasNext();) {			String key = iterator.next();			Class c = iterator2.next();			Method method = Modchu_Reflect.getMethod(c, "load");			boolean deleteFlag = true;			if (method != null) {				Object o = Modchu_Reflect.newInstance(c.getName());				if (o != null) {					modInstanceMap.put(key, o);					deleteFlag = false;					if (getModEnabled(o)) Modchu_Reflect.invoke(method, o);					else {						Modchu_Debug.mDebug("registerMods getModDisabled c="+c);					}				}			}			if (deleteFlag) deleteList.add(key);		}		if (!deleteList.isEmpty()) {			for (Iterator<String> iterator = deleteList.iterator(); iterator.hasNext();) {				modClassMap.remove(iterator.next());			}		}	}	public static boolean isMod(String s) {		return modInstanceMap.containsKey(s);	}	public static boolean isModEnabled(String s) {		Object o = modInstanceMap.get(s);		return o != null ? getModEnabled(o) : false;	}	public static String getModVersion(String s) {		Object o = modInstanceMap.get(s);		return o != null ? Modchu_CastHelper.String(Modchu_Reflect.invokeMethod(o.getClass(), "getVersion", o, -1)) : null;	}	private static boolean getModEnabled(Object o) {		Object o1 = Modchu_Reflect.invokeMethod(o.getClass(), "modEnabled", o, -1);		//Modchu_Debug.mDebug("getModEnabled c="+o1.getClass());		//Modchu_Debug.mDebug("getModEnabled o1="+o1);		//Modchu_Debug.mDebug("getModEnabled Modchu_CastHelper.Boolean(o1)="+Modchu_CastHelper.Boolean(o1));		return (o1 != null				&& Modchu_CastHelper.Boolean(o1))				| o1 == null;	}	public static void eventRegister(Object o) {		//Modchu_Debug.mDebug("Modchu_Main eventRegister o="+o);		if (!eventObjectList.contains(o)) {			//Modchu_Debug.mDebug("Modchu_Main eventRegister ok.");			eventObjectList.add(o);		}	}	public static void eventUnRegister(Object o) {		if (eventObjectList.contains(o)) eventObjectList.remove(o);	}	public static void registerKey(Object modInstance, Object keyBinding, boolean b) {		//Modchu_Debug.mDebug("Modchu_Main registerKey b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));		if (!isForge) Modchu_Reflect.invokeMethod("ModLoader", "registerKey", new Class[]{ Modchu_Reflect.loadClass("BaseMod"), Modchu_Reflect.loadClass("KeyBinding"), boolean.class }, new Object[]{ modInstance, keyBinding, false});		else if (isForge			&& getMinecraftVersion() > 169) {			Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.ClientRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("KeyBinding") }, new Object[]{ keyBinding });			if (!eventKeyBindingList.contains(keyBinding)					&& keyBinding instanceof KeyBinding) {				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. keyBinding="+keyBinding);				eventKeyBindingList.add((KeyBinding) keyBinding);				eventKeyBindingObjectMap.put(keyBinding, new Object[]{ modInstance, b });				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. o="+eventKeyBindingObjectMap.get(keyBinding));			}		}	}	public static void registerKeyHandler(Object handler) {		if (isForge				&& getMinecraftVersion() < 170) ;else return;		Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.KeyBindingRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("cpw.mods.fml.client.registry.KeyBindingRegistry$KeyHandler") }, new Object[]{ handler });	}	public static void addLocalization(String s, String s2) {		if (Modchu_Main.isForge) Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.LanguageRegistry", "addStringLocalization", new Class[]{ String.class, String.class }, Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.LanguageRegistry", "instance"), new Object[]{ s, s2 });		else Modchu_Reflect.invokeMethod("ModLoader", "addLocalization", new Class[]{ String.class, String.class }, new Object[]{ s, s2 });	}	public static void keyboardEvent(Object keybinding) {		if (eventKeyBindingList.isEmpty()) return;		keybinding = null;		for (int i = 0; i < eventKeyBindingList.size() ; i++) {			keybinding = eventKeyBindingList.get(i);			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent keyBinding="+keybinding);			Object[] o = eventKeyBindingObjectMap.get(keybinding);			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent o="+o);			if (o != null					&& o.length > 1) ;else continue;			Object modInstance = o[0];			boolean b = Modchu_CastHelper.Boolean(o[1]);			if (b					| (!b							&& Modchu_AS.getBoolean(Modchu_AS.keyBindingIsPressed, keybinding))) {				//Modchu_Debug.mDebug("Modchu_Main keyInput ok. b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keybinding));				if (modInstance != null) Modchu_Reflect.invokeMethod(modInstance.getClass(), "keyboardEvent", new Class[]{ Object.class }, modInstance, new Object[]{ keybinding }, -1);			}		}	}	public static void clientConnect(Object o) {		eventObjectLoad("clientConnect", new Class[]{ Object.class }, new Object[]{ o });	}	public static void onWorldLoad(Object o) {		eventObjectLoad("onWorldLoad", new Class[]{ Object.class }, new Object[]{ o });	}	public static boolean onTickInGame(float f, Object minecraft, byte type, Object... tickData) {		eventObjectLoad("onTickInGame", new Class[]{ byte.class, Object[].class }, new Object[]{ type, (Object[])tickData });		//isRemote = !isRemote;		if (Modchu_Debug.debugMessage				&& type == 2				) {			Modchu_Debug.dDebugDrow();		}		//if (!isRemote) return true;		if (runtimeExceptionFlag) throw new RuntimeException(runtimeExceptionString);		return true;	}	static void eventObjectLoad(String s, Class[] cla, Object[] oa) {		if (eventObjectList.isEmpty()				| eventObjectLoadCheckList.contains(s)) return;		boolean b = false;		for (int i = 0; i < eventObjectList.size() ; i++) {			Object modInstance = eventObjectList.get(i);			if (modInstance != null) {				Method medhod = Modchu_Reflect.getMethod(modInstance.getClass(), s, cla, -1);				if (medhod != null) {					Modchu_Reflect.invoke(medhod, modInstance, oa, -1);					b = true;				}			}		}		//if (!b) eventObjectLoadCheckList.add(s);	}	public static void loadcfg() {		// cfg読み込み		if (cfgdir.exists()) {			if (!mainCfgfile.exists()) {				// cfgファイルが無い = 新規作成				String s[] = {						"debugMessage=true", "debugMessagetexture=false", "debugReflectMessage=true", "debugReflectMessageDetail=false", "versionCheck=true",						"debugLogMessage=false", "careerSave=false", "debugSystemMessage=false"				};				Modchu_Config.writerConfig(mainCfgfile, s);			} else {				// cfgファイルがある				Modchu_Debug.debugMessage = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugMessage", Modchu_Debug.debugMessage)).toString());				Modchu_Debug.debugMessagetexture = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugMessagetexture", Modchu_Debug.debugMessagetexture)).toString());				Modchu_Reflect.debugReflectMessage = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessage", Modchu_Reflect.debugReflectMessage)).toString());				Modchu_Reflect.debugReflectMessageDetail = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessageDetail", Modchu_Reflect.debugReflectMessageDetail)).toString());				versionCheck = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "versionCheck", versionCheck)).toString());				Modchu_Debug.debugLogMessage = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugLogMessage", Modchu_Debug.debugLogMessage)).toString());				Modchu_Debug.careerSave = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "careerSave", Modchu_Debug.careerSave)).toString());				Modchu_Debug.debugSystemMessage = Boolean.valueOf((Modchu_Config.loadConfig(mainCfgfile, "debugSystemMessage", Modchu_Debug.debugSystemMessage)).toString());				String k[] = {						"debugMessage", "debugMessagetexture", "debugReflectMessage", "debugReflectMessageDetail", "versionCheck",						"debugLogMessage", "careerSave", "debugSystemMessage"				};				String k1[] = {						""+Modchu_Debug.debugMessage, ""+Modchu_Debug.debugMessagetexture, ""+Modchu_Reflect.debugReflectMessage, ""+Modchu_Reflect.debugReflectMessageDetail, ""+versionCheck,						""+Modchu_Debug.debugLogMessage, ""+Modchu_Debug.careerSave, ""+Modchu_Debug.debugSystemMessage				};				Modchu_Config.writerSupplementConfig(mainCfgfile, k, k1);			}		}	}	public static boolean isRelease() {		return isRelease;	}	public static String getClassName(String s) {/*		if (s == null) return null;		if (s.indexOf(".") > -1) return s;		String s1 = getPackage();		if (s1 != null) return s1.concat(".").concat(s);*/		return s;	}	public static void getPackageInit() {		//if (!isForge) {		Package pack = modchu_Main.getClass().getPackage();		if (pack != null) packageName = pack.getName();		else packageName = null;/*		} else {			packageName = !isRelease ? "net.minecraft.src" : null;		}*/	}	public static String getPackage() {		return packageName;	}	public static Object getHashMapKey(HashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	public static Object getConcurrentHashMapKey(ConcurrentHashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	private static void startVersionCheckThread() {		Modchu_ThreadVersionCheck var0 = new Modchu_ThreadVersionCheck();		var0.start();	}	public static boolean checkRelease(String s) {		if (s != null) {			if (s.length() > 1) {				String ck = s.substring(s.length() - 1, s.length());				String mck = Modchu_Main.getVersion();				String k = version;				mck = k.substring(k.length() - 1);				if (integerCheck(mck)) mck = "";				boolean check = integerCheck(k);				//Modchu_Debug.mDebug("Modchulib checkRelease k="+k+" mck="+mck+" check="+check);				while(!check						&& k.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease k="+k);					check = integerCheck(k.substring(0, k.length() - 1));					k = k.substring(0, k.length() - 1);				}				int m = Integer.valueOf(k);				//Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck);				if (integerCheck(ck)) ck = "";				check = integerCheck(s);				while(!check						&& s.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease s="+s);					check = integerCheck(s.substring(0, s.length() - 1));					s = s.substring(0, s.length() - 1);				}				int i = Integer.valueOf(s);				Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck+" i="+i+" ck="+ck);				if (i > m) {					return true;				}				if (i == m						&& ck.compareTo(mck) > 0) {					return true;				}				return false;			}		}		return false;	}	public static int integerCheckReturnInt(String s) {		try {			Integer.valueOf(s);			return 1;		} catch (Exception e) {			try {				Long.valueOf(s);				return 2;			} catch (Exception e1) {				return -1;			}		}	}	public static boolean integerCheck(String s) {		try {			Integer.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean floatCheck(String s) {		try {			Float.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean doubleCheck(String s) {		try {			Double.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean byteCheck(String s) {		try {			Byte.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static int getVersionStringConversionInt(String s) {		int i = 0;		if (s.length() > 1) {			String s1 = s.substring(s.length() - 1);			s = s.substring(0, s.length() - 1);			i = Integer.parseInt(s) * 100 + s1.compareTo("a") + 1;		} else {			i = Integer.parseInt(s) * 100;		}		return i;	}	public static void setNewRelease(String s) {		newRelease = true;		newVersion = s;	}	public static String lastIndexProcessing(String t, String t1) {		int j = t.lastIndexOf(t1);		if(j > -1) return t.substring(j + 1);		return t;	}	public static HashMap cloneHashMap(HashMap hashMap) {		HashMap map = new HashMap();		Iterator iterator = hashMap.entrySet().iterator();		Entry entry;		Object key;		Object value;		while (iterator.hasNext()) {			entry = (Entry)iterator.next();			key = entry.getKey();			value = entry.getValue();			map.put(key, value);		}		return map;	}	public static int hashMapKeyCount(HashMap hashMap) {		int i = 0;		Iterator iterator = hashMap.entrySet().iterator();		Object entry;		while (iterator.hasNext()) {			entry = iterator.next();			i++;		}		return i;	}	public static int intNormalise(int i, int min, int max) {		return intNormalise(i, min, max, false);	}	public static int intNormalise(int i, int min, int max, boolean b) {		if (i < min) i = b ? max : min;		if (i > max) i = b ? min : max;		return i;	}	public static float floatNormalise(float f, float min, float max) {		return floatNormalise(f, min, max, false);	}	public static float floatNormalise(float f, float min, float max, boolean b) {		if (f < min) f = b ? max : min;		if (f > max) f = b ? min : max;		return f;	}	public static double doubleNormalise(double d, double min, double max) {		return doubleNormalise(d, min, max, false);	}	public static double doubleNormalise(double d, double min, double max, boolean b) {		if (d < min) d = b ? max : min;		if (d > max) d = b ? min : max;		return d;	}	public static Object[] ByteToObjectArray(byte[] by) {		Object[] o = new Object[by.length];		for(int i = 0; i < by.length; i++) {			o[i] = by[i];		}		return o;	}	public static Object[] FloatToObjectArray(float[] fl) {		Object[] o = new Object[fl.length];		for(int i = 0; i < fl.length; i++) {			o[i] = fl[i];		}		return o;	}	public static Object[] DoubleToObjectArray(double[] dou) {		Object[] o = new Object[dou.length];		for(int i = 0; i < dou.length; i++) {			o[i] = dou[i];		}		return o;	}	public static Object[] IntToObjectArray(int[] in) {		Object[] o = new Object[in.length];		for(int i = 0; i < in.length; i++) {			o[i] = in[i];		}		return o;	}	public static int getMinecraftVersion() {		return Modchu_Main.modchuLibVersion;	}}