package modchu.lib;import java.awt.image.BufferedImage;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.lang.annotation.Annotation;import java.lang.reflect.Array;import java.lang.reflect.Method;import java.nio.ByteBuffer;import java.nio.ByteOrder;import java.nio.FloatBuffer;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.concurrent.ConcurrentHashMap;import modchu.lib.characteristic.Modchu_AS;import modchu.lib.characteristic.Modchu_AllRenderLiving;import modchu.lib.characteristic.Modchu_CastHelper;import modchu.lib.characteristic.Modchu_EntityTameable;import modchu.lib.characteristic.Modchu_GlStateManager;import modchu.lib.characteristic.Modchu_GuiBase;import modchu.lib.characteristic.Modchu_Item;import modchu.lib.characteristic.Modchu_RenderPlayer;import modchu.lib.characteristic.Modchu_Version;import modchu.model.ModchuModel_Main;import net.minecraft.src.mod_Modchu_ModchuLib;import org.lwjgl.Sys;import org.lwjgl.opengl.Display;import org.lwjgl.opengl.GL11;import org.lwjgl.opengl.GL12;public class Modchu_Main {	public static final String version = "10g";	//cfg書き込み項目	public static boolean versionCheck = true;	public static final String modName = "ModchuLib";	public static final String versionString = ""+ Modchu_Version.version + "-" + version;	public static ConcurrentHashMap<String, Class> modClassMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Object> modInstanceMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Object, Object[]> eventKeyBindingObjectMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Boolean> modEnabledMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Byte> modDisableMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Class, Object[]> spawnMobMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Class, Object> tempEntityRenderMap;	public static List<File> modFileList = new ArrayList();	private static ArrayList eventObjectList = new ArrayList();	private static ArrayList modchuLibEventObjectList = new ArrayList();	private static ArrayList eventKeyBindingList = new ArrayList();	private static ArrayList<String> eventObjectLoadCheckList = new ArrayList(1024);	private static ArrayList<String> modchuLibEventObjectLoadCheckList = new ArrayList(1024);	public static mod_Modchu_ModchuLib baseModInstance;	private static Modchu_GuiBase guiMainInitMaster;	private static Modchu_FontRenderer fontRenderer;	private static Object logo;	private static Object modsLoadedLoadScreen;	public static Object mc;	private static int tempBufferedimageId = -1;	private static int fontColor;	private static double[] textureRect;	private static BufferedImage tempBufferedImage;	private static BufferedImage tempBackGround;	public static Class itemRendererClass;	public static String newVersion = "";	public static String packageName;	public static LinkedList<String> runtimeExceptionStringList;	public static File cfgdir;	public static File modsDir;	private static File mainCfgfile;	private static File modListCfgfile;	public static final int modchuLibVersion = Modchu_Version.version;	public static int mmmLibVersion;	public static boolean isServer = false;	public static boolean isForge = false;	public static boolean isItemRendererHD = false;	public static boolean isHD = false;	public static boolean isAether = false;	public static boolean isOlddays = false;	public static boolean newRelease = false;	public static boolean oldRenderItems = false;	public static boolean runtimeExceptionFlag = false;	public static boolean isRelease = true;	private static boolean isItemRendererDebug = false;	private static boolean packageNameNull = false;	private static boolean isRemote = false;	private static boolean initModsLoadedLoadScreenFlag = false;	public static boolean initModsLoaded = false;	public static boolean initLoad = false;	public static boolean initLoadcfg = false;	public static boolean initModsLoadedStating = false;	private static int initLoadCount = 0;	private static final int maxInitLoadCount = 14;	public static final byte tickByte_ClientTickEvent = 1;	public static final byte tickByte_RenderTickEvent = 2;	public static final byte tickByte_ServerTickEvent = 3;	public static final byte tickByte_WorldTickEvent = 4;	public static final byte tickByte_PlayerTickEvent = 5;	public static final byte tickByte_OtherTickEvent = 6;	// ~164	private static ConcurrentHashMap<Object, Boolean> keyBindingsMap;	public static void init() {		Modchu_AS.instanceCheck();		Modchu_Debug.systemLogDebug("(1 / 3) - (1 / 2) Modchu_Main static");		//対応MOD導入チェック class直チェック		HashMap<String, Boolean> map = new HashMap();		boolean tempIsClient = false;		boolean tempIsRenderPlayer2 = false;		if (getMinecraftVersion() > 179) map.put("net.minecraftforge.fml.common.FMLCommonHandler", isForge);		map.put("net.minecraft.client.Minecraft", tempIsClient);		if (getMinecraftVersion() < 180) {			map.put("FMLRenderAccessLibrary", isForge);			map.put("net.minecraft.src.FMLRenderAccessLibrary", isForge);			if (getMinecraftVersion() < 164) {				map.put("ItemRendererHD", isItemRendererHD);				map.put("RenderPlayer2", tempIsRenderPlayer2);				map.put("net.minecraft.src.Minecraft", tempIsClient);				if (getMinecraftVersion() == 162) map.put("ats", tempIsClient);			}		}		Class test2 = null;		for (Entry<String, Boolean> en : map.entrySet()) {			String s = en.getKey();			try {				test2 = Class.forName(s);				if (test2 != null) {					Modchu_Debug.lDebug(test2.getName() + " Check ok.");					if (s.equals("net.minecraftforge.fml.common.FMLCommonHandler")							| s.equals("FMLRenderAccessLibrary")							| s.equals("net.minecraft.src.FMLRenderAccessLibrary")) {						isForge = true;					}					if (s.equals("net.minecraft.client.Minecraft")							| s.equals("net.minecraft.src.Minecraft")							| s.equals("ats")) {						tempIsClient = true;					}					if (s.equals("ItemRendererHD")) isItemRendererHD = true;					if (s.equals("RenderPlayer2")) tempIsRenderPlayer2 = true;				}			} catch (Exception e) {			}		}		Modchu_Debug.lDebug("Modchu_Main init() isForge="+isForge);		Modchu_Debug.lDebug("Modchu_Main init() tempIsClient="+tempIsClient);		if (tempIsRenderPlayer2) {			try {				Object o = Modchu_Reflect.getFieldObject("ItemRenderer", "olddays", -1);				if (o != null) {					isOlddays = true;					Modchu_Debug.lDebug("ItemRenderer olddays Check ok.");				} else {					Modchu_Debug.lDebug("ItemRenderer olddays Check false.");				}			} catch(Exception e) {			}		}		Modchu_Debug.systemLogDebug("(1 / 3) - (2 / 3) Modchu_Main static");		File mcDataDir = tempIsClient ? Modchu_AS.getFile(Modchu_AS.minecraftMcDataDir) : new File(".");		Modchu_Debug.lDebug("Modchu_Main init() mcDataDir="+mcDataDir.getAbsolutePath());		String s = mcDataDir.getAbsolutePath();		//Modchu_Debug.lDebug("Modchu_Main load() new File= "+(new File(new File(s, "../"), "gradle")));		if (s.indexOf("jars") != -1				| new File(s, "gradle").exists()				| new File(new File(s, "../"), "gradle").exists()) {			isRelease = false;		}		Modchu_Debug.lDebug("Modchu_Main static isRelease="+isRelease);		Modchu_Reflect.initNameMap();		Object o = Modchu_Reflect.invokeMethod("FMLCommonHandler", "instance");		if (o != null) {			o = Modchu_Reflect.invokeMethod(o.getClass(), "getSide", o);			if (o != null) {				if ((Boolean) Modchu_Reflect.invokeMethod(o.getClass(), "isServer", o)) isServer = true;				Modchu_Debug.systemLogDebug("(1 / 3) - (3 / 3) Modchu_Main static Forge isServer="+isServer);			} else {				Modchu_Debug.systemLogDebug("(1 / 3) - (3 / 3) Modchu_Main static o == null !!");			}		} else {			isServer = Modchu_Reflect.invokeMethod("ModLoader", "getMinecraftInstance") == null;			Modchu_Debug.systemLogDebug("(1 / 3) - (3 / 3) Modchu_Main static ModLoader isServer="+isServer);		}	}	public static String getName() {		return modName;	}	public static String getVersion() {		return versionString;	}	public static void load(mod_Modchu_ModchuLib base) {		load_LoadCountSetting();		baseModInstance = base;		String mcVersion = baseModInstance.getMcVersion();		String minecraftVersionString = Modchu_Version.getMinecraftVersionString();		if (!mcVersion.equals(minecraftVersionString)				&& mcVersion.indexOf(minecraftVersionString) < 0) {/*			if (!(minecraftVersionString.equals("1.6.4")					| minecraftVersionString.equals("1.7.2")					&& mcVersion.equals("1.6"))) {*/				String s = "ModchuLib Minecraft adaptation version error !! mcVersion="+mcVersion+" Modchu_Version.getMinecraftVersionString()="+Modchu_Version.getMinecraftVersionString();				setRuntimeException(s);				throw new RuntimeException(s);			//}		}		//Modchu_Debug.lDebug("Modchu_Main load() mcVersion="+mcVersion+" Modchu_Version.getMinecraftVersionString()="+Modchu_Version.getMinecraftVersionString());		if (!isServer) load_loadingLogo();		load_installationModCheck();		if (!isItemRendererHD) {			Modchu_Debug.lDebug("Modchu_Main load()  No ItemRendererHD.");		}		if (isItemRendererHD) {			Object b = Modchu_Reflect.getFieldObject("ItemRendererHD", "debug");			if (b != null					&& (Boolean) b) {				isItemRendererDebug = true;			}		}		isHD = isItemRendererHD				&& !isItemRendererDebug;		itemRendererClass = isHD ? Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRendererHD") : Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRenderer");		load_LoadCountSetting();		if (!isServer				&& isForge				&& getMinecraftVersion() < 170) {			if (keyBindingsMap != null); else keyBindingsMap = new ConcurrentHashMap();		}		load_LoadCountSetting();		File mcDataDir = Modchu_AS.getFile(Modchu_AS.minecraftMcDataDir);		cfgdir = new File(mcDataDir, "/config/");		mainCfgfile = new File(cfgdir, ("Modchu_ModchuLib.cfg"));		modListCfgfile = new File(cfgdir, ("Modchu_ModchuLibModList.cfg"));		String s = null;		if (!isForge 				&& getMinecraftVersion() == 162) {			File versionsDir = new File(mcDataDir, "/versions/");			s = Modchu_AS.getString(Modchu_AS.minecraftLaunchedVersion);			File version = versionsDir != null					&& s != null ? new File(versionsDir, s) : null;			modsDir = new File(version != null					&& versionsDir.exists()					&& versionsDir.isDirectory()					&& version.exists()					&& version.isDirectory() ? version : mcDataDir, "/mods/");		} else {			modsDir = isServer ? new File(".", "/mods/") : new File(mcDataDir, "/mods/");		}		Modchu_Debug.lDebug("Modchu_Main load() modsDir="+modsDir);		load_LoadCountSetting();		loadcfg();		Modchu_Debug.systemDebug("Modchu_Main load()", 1);		load_LoadCountSetting();		mmmLibVersion = -1;		Class MMMLib = Modchu_Reflect.loadClass("mmm.lib.MMMLib", -1);		if (MMMLib != null) {			s = null;			for (Annotation a : MMMLib.getDeclaredAnnotations()) {				//Modchu_Debug.lDebug("Modchu_Main load() MMMLib Annotation a="+a);				s = a.toString();			}			if (s != null					&& !s.isEmpty()) {				s = getInsideParentheses(s);				//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion s="+s);				if (s != null						&& !s.isEmpty()) {					s = s.replaceAll(" ", "");					String[] s0 = s.split(",");					//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion s0="+s0);					if (s0 != null							&& s0.length > 0) {						for (String s1 : s0) {							if (s1.startsWith("version")) {								//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion version ok.s1="+s1);								int i1 = s1.indexOf("=");								if (i1 > -1) {									s1 = lastIndexProcessing(s1, "=");									i1 = s1.indexOf("-");									if (i1 > -1) {										s = lastIndexProcessing(s1, "-");										//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion version ok.end s="+s);										int i = getVersionStringConversionInt(s);										mmmLibVersion = 1000 + i;									}								}							}						}					}				}			}		} else {			MMMLib = Modchu_Reflect.loadClass("mod_MMM_MMMLib", -1);			if (MMMLib != null) {				s = (String) Modchu_Reflect.getFieldObject(MMMLib, "Revision");				int i = getVersionStringConversionInt(s);				mmmLibVersion = i;			}		}		//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion="+mmmLibVersion);		load_LoadCountSetting();		Modchu_FileManager.init();		Modchu_FileManager.getModFile(modsDir, modFileList, modClassMap, "modc_");		Modchu_FileManager.addResourcesMod(Modchu_Main.class, modClassMap, "modc_");		load_LoadCountSetting();		loadModListcfg();		load_LoadCountSetting();		registerMods();		load_LoadCountSetting();		initModEnabledMap();		load_LoadCountSetting();		saveModListcfg();		load_LoadCountSetting();		addSpawn();		load_LoadCountSetting();		initRegisterKeyHandler();		load_LoadCountSetting();		if (versionCheck) startVersionCheckThread();		load_LoadCountSetting();		initLoad = true;		Modchu_Debug.lDebug("Modchu_Main load() end.");	}	private static void load_loadingLogo() {		new Modchu_RenderEngine();		fontRenderer = new Modchu_FontRenderer(newResourceLocation("textures/font/ascii.png"), false);		fontRenderer.onResourceManagerReload(null);		resetFontColor();		logo = Modchu_Main.newResourceLocation("textures/gui/title/modchulib_title.png");		if (logo != null); else {			String s = "Modchu_Main load logo == null !!";			Modchu_Main.setRuntimeException(s);			throw new NullPointerException(s);		}		loadScreen(logo);		if (getMinecraftVersion() < 170) {			Display.update();			loadScreen(logo);			Display.update();		}	}	private static void load_installationModCheck() {		if (Modchu_Main.isForge) {			Object o = Modchu_Reflect.invokeMethod("Loader", "instance");			if (o != null) {				List list = Modchu_CastHelper.List(Modchu_Reflect.invokeMethod("Loader", "getActiveModList", o));				if (list != null) {					int size = list.size();					String name = null;					for (int i = 0; i < size; i++) {						o = list.get(i);						name = Modchu_CastHelper.String(Modchu_Reflect.invokeMethod("ModContainer", "getName", o));						if (name.startsWith("Aether")) {							isAether = true;							Modchu_Debug.lDebug("Aether Check ok.");						}					}				}			}		}		if (!isAether) {			Modchu_Debug.lDebug("isAether false.");		}		if (!isOlddays) {			Modchu_Debug.lDebug("No Olddays.");		}	}	private static void load_LoadCountSetting() {		initLoadCount++;		Modchu_Debug.systemLogDebug(new StringBuilder().append("(2 / 3) - (").append(initLoadCount).append(" / ").append(maxInitLoadCount).append(") Modchu_Main load()").toString());	}	public static void init(Object event) {		Modchu_Debug.lDebug("Modchu_Main init");		for (Entry<String, Object> en : modInstanceMap.entrySet()) {			Object o = en.getValue();			Class c = o.getClass();			if (getModEnabled(o)) {				Modchu_Debug.lDebug("Modchu_Main init c="+c);				Method method = Modchu_Reflect.getMethod(c, "init", new Class[]{ Object.class }, -1);				if (method != null) {					try {						Modchu_Debug.lDebug("Modchu_Main init 1");						Modchu_Reflect.invoke(method, o, event);					} catch (Error e) {						e.printStackTrace();					} catch (Exception e) {						e.printStackTrace();					}				}			}		}	}	public static void modsLoaded() {		Modchu_Debug.systemLogDebug("(3 / 3) - (1 / 2) Modchu_Main modsLoaded()");		if (initLoadCount != maxInitLoadCount) Modchu_Main.setRuntimeException("Modchu_Main load() init error !! initLoadCount="+initLoadCount);		baseModInstance.loadCheckThread = null;		if (modInstanceMap.isEmpty()) return;		int count = 0;		int loadCount = 0;		setFontColor(0);		String s = null;		int version = getMinecraftVersion();		int displayWidth = Modchu_AS.getInt(Modchu_AS.minecraftDisplayWidth);		int displayHeight = Modchu_AS.getInt(Modchu_AS.minecraftDisplayHeight);		if (!isServer) {			//Modchu_GlStateManager.pushMatrix();			//Modchu_GlStateManager.pushAttrib();		}		for (Entry<String, Object> en : modInstanceMap.entrySet()) {			//Modchu_Debug.dDebug("ModchuLib modsLoaded Loading ("+loadCount+" / 100) Please wait.", 1);			count++;			loadCount+= 100 / modInstanceMap.size();			if (count == modInstanceMap.size()) loadCount = 100;			if (loadCount > 100) loadCount = 100;			Object o = en.getValue();			Class c = o.getClass();			if (getModEnabled(o)) {				long time = 0;				if (!isServer) {					Object tempLogo = Modchu_Reflect.invokeMethod(c, "getModsLoadedLoadScreen", o, -1);					//Modchu_Debug.mDebug("Modchu_Main modsLoaded c="+c+" tempLogo="+tempLogo, 2);					initModsLoadedLoadScreenFlag = true;					Object[] o1 = null;					for (int i1 = 0; i1 < 2; i1++) {						s = "ModchuLib modsLoaded Loading ("+loadCount+" / 100) Please wait.";						if (version > 179) {							// TODO							Modchu_AS.set(Modchu_AS.loadingScreenResetProgressAndMessage, s);							Modchu_AS.set(Modchu_AS.loadingScreenSetLoadingProgress, loadCount);						} else {							o1 = logoModsLoadedLoadScreen(tempLogo != null ? tempLogo : Modchu_Main.newResourceLocation("textures/gui/title/modchulib_title.png"));							Modchu_GlStateManager.pushMatrix();							drawString(s, displayWidth / 4 - (s.length() / 2 * 5), displayHeight / 4 + 60, 0);							drawString("Loading ModchuLib Mod = "+c.getSimpleName(), displayWidth / 4 - (s.length() / 2 * 5), displayHeight / 4 + 70, 0);							Modchu_GlStateManager.popMatrix();							//mdrawString("tempLogo="+tempLogo, 0, 10, 0);							int sizeX = 300;							int sizeY = 20;							int posY = 70;							laterFramebufferSetting(o1[0], (Integer)o1[1], (Integer)o1[2], (Integer)o1[3]);							drawSquare(displayWidth / 2 - (sizeX / 2), displayHeight / 2 + posY, sizeX, sizeY, 0x000000);							if (loadCount > 0) {								int sizeX2 = sizeX * loadCount / 100;								//Modchu_Debug.mDebug("Modchu_Main modsLoaded sizeX2 ="+sizeX2);								drawSquare(displayWidth / 2 - (sizeX / 2) + 1, displayHeight / 2 + posY + 1, sizeX2 - 2, sizeY - 2, 0x0000ff);							}						}						if (version < 170) Display.update();					}					if (version > 169) Display.update();					//if (tempLogo != null); else Modchu_Debug.debugKeyPush();					time = getMillisecond();					if (loadCount > 0) {						try {							Thread.sleep(1L);						} catch (InterruptedException e) {						}					}				}				Method method = Modchu_Reflect.getMethod(c, "modsLoaded", -1);				if (method != null) {					try {						Modchu_Reflect.invoke(method, o);					} catch (Error e) {						e.printStackTrace();					} catch (Exception e) {						e.printStackTrace();					}				}				if (!isServer) {					if (time + 59L > getMillisecond()) {						try {							long l = time + 59L - getMillisecond();							//Modchu_Debug.mDebug("Modchu_Main modsLoaded sleep time ="+l);							if (l > 0L) Thread.sleep(l);						} catch (Exception e) {						}					}				}			}		}		resetFontColor();		if (tempBufferedImage != null) {			tempBufferedImage.flush();			tempBufferedImage = null;		}		if (!isServer) {			//Modchu_GlStateManager.popAttrib();			//Modchu_GlStateManager.popMatrix();			Display.update();			loadScreenGLEnd();		}		setModsLoadedLoadScreen(null);		Modchu_Debug.systemLogDebug("(3 / 3) - (2 / 2) Modchu_Main modsLoaded() end.");		initModsLoaded = true;	}	private static void registerMods() {		if (modClassMap != null				&& !modClassMap.isEmpty()); else {			Modchu_Debug.Debug("Modchu_Main registerMods() modClassMap.isEmpty()");			return;		}		ArrayList<String> deleteList = new ArrayList();		for (Entry<String, Class> en : modClassMap.entrySet()) {			String key = en.getKey();			Class c = en.getValue();			Method method = Modchu_Reflect.getMethod(c, "load");			boolean deleteFlag = true;			if (method != null) {				Object o = Modchu_Reflect.newInstance(c.getName());				if (o != null) {					if (!modInstanceMap.containsKey(key)) {						modInstanceMap.put(key, o);						if (isModUse(key)) {							boolean errorFlag = false;							try {								Modchu_Debug.lDebug("Modchu_Main registerMods() load invoke c="+c);								Modchu_Reflect.invoke(method, o);							} catch (Error e) {								Modchu_Debug.lDebug("Modchu_Main registerMods() Error !! c="+c, 2, e);								errorFlag = true;							} catch (Exception e) {								Modchu_Debug.lDebug("Modchu_Main registerMods() Exception !! c="+c, 2, e);								errorFlag = true;							}							if (errorFlag) {								try {									Modchu_Debug.lDebug("Modchu_Main error class="+c);									Class[] c1 = c.getDeclaredClasses();									Modchu_Debug.lDebug("Modchu_Main error class.getDeclaredClasses()="+c1);									if (c1 != null) {										for (Class c2 : c1) {											Modchu_Debug.lDebug("Modchu_Main error class.getDeclaredClasses() class="+c2);										}									}								} catch (Error e) {									Modchu_Debug.lDebug("Modchu_Main errorFlag check Error !!", 2, e);									e.printStackTrace();								} catch (Exception e) {									Modchu_Debug.lDebug("Modchu_Main errorFlag check Exception !!", 2, e);									e.printStackTrace();								}							}							deleteFlag = false;						} else {							Modchu_Debug.lDebug("Modchu_Main registerMods() getModDisabled c="+c);						}					}				}			}			if (deleteFlag) deleteList.add(key);		}		if (!deleteList.isEmpty()) {			for (String key : deleteList) {				Object o = modInstanceMap.get(key);				boolean b = o != null ? getModEnabled(o) : false;				byte by = (byte) (b ? 2 : 0);				if (!isModUse(key)) by += (byte) 1;				if (!modDisableMap.containsKey(key)) modDisableMap.put(key, by);				modClassMap.remove(key);				modInstanceMap.remove(key);			}		}	}	public static boolean isMod(String s) {		return modInstanceMap.containsKey(s)				| modDisableMap.containsKey(s);	}	public static boolean isModEnabled(String s) {		byte by = getModDisableByte(s);		Object o = modInstanceMap.get(s);		return o != null ? getModEnabled(o) : by >= 2 ? true : false;	}	public static boolean isModUserEnabled(String s) {		byte by = getModDisableByte(s);		return modEnabledMap != null				&& modEnabledMap.containsKey(s) ? modEnabledMap.get(s) : by == 0				| by == 1				| by == 3 ? true : false;	}	public static boolean isModUse(String key) {		return isModEnabled(key)				&& isModUserEnabled(key);	}	private static byte getModDisableByte(String s) {		return modDisableMap != null				&& modDisableMap.containsKey(s) ? modDisableMap.get(s) : 0;	}	public static String getModVersion(String s) {		Object o = modInstanceMap.get(s);		return o != null ? Modchu_CastHelper.String(Modchu_Reflect.invokeMethod(o.getClass(), "getVersion", o, -1)) : null;	}	private static boolean getModEnabled(Object o) {		Object o1 = Modchu_Reflect.invokeMethod(o.getClass(), "modEnabled", o, -1);		//Modchu_Debug.mDebug("getModEnabled c="+o1.getClass());		//Modchu_Debug.mDebug("getModEnabled o1="+o1);		//Modchu_Debug.mDebug("getModEnabled Modchu_CastHelper.Boolean(o1)="+Modchu_CastHelper.Boolean(o1));		return (o1 != null				&& Modchu_CastHelper.Boolean(o1))				| o1 == null;	}	public static void eventRegister(Object o) {		//Modchu_Debug.mDebug("Modchu_Main eventRegister o="+o);		if (!getEventObjectList().contains(o)) {			//Modchu_Debug.mDebug("Modchu_Main eventRegister ok.");			getEventObjectList().add(o);		} else {			//Modchu_Debug.mDebug("Modchu_Main eventRegister out o="+o);		}	}	public static void modchuLibEventRegister(Object o) {		//Modchu_Debug.mDebug("Modchu_Main modchuLibEventRegister o="+o);		if (!getModchuLibEventObjectList().contains(o)) {			//Modchu_Debug.mDebug("Modchu_Main modchuLibEventRegister ok.");			getModchuLibEventObjectList().add(o);		}	}	public static void eventUnRegister(Object o) {		if (getEventObjectList().contains(o)) getEventObjectList().remove(o);	}	public static void modchuLibEventUnRegister(Object o) {		if (getModchuLibEventObjectList().contains(o)) getModchuLibEventObjectList().remove(o);	}	public static void registerKey(Object modInstance, Object keyBinding, boolean b) {		//Modchu_Debug.mDebug("Modchu_Main registerKey b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));		if (isServer) return;		if (!isForge) {			Class baseMod = Modchu_Reflect.loadClass("net.minecraft.src.BaseMod");			if (baseMod != null) Modchu_Reflect.invokeMethod("ModLoader", "registerKey", new Class[]{ baseMod, Modchu_Reflect.loadClass("KeyBinding"), boolean.class }, new Object[]{ baseMod.isInstance(modInstance) ? modInstance : baseModInstance, keyBinding, false});			else {				Modchu_Debug.lDebug("Modchu_Main registerKey baseMod.class == null error !!");			}		}		else if (isForge) {			if (getMinecraftVersion() > 169) Modchu_Reflect.invokeMethod("ClientRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("KeyBinding") }, new Object[]{ keyBinding });			if (!eventKeyBindingList.contains(keyBinding)					&& Modchu_Reflect.loadClass("KeyBinding").isInstance(keyBinding)) {				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. keyBinding="+keyBinding);				eventKeyBindingList.add(keyBinding);				eventKeyBindingObjectMap.put(keyBinding, new Object[]{ modInstance, b });				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. o="+eventKeyBindingObjectMap.get(keyBinding));			}			if (getMinecraftVersion() < 170) {				//Modchu_Debug.mDebug("registerKey keyBinding="+keyBinding);				keyBindingsMap.put(keyBinding, b);			}		}	}	private static void initRegisterKeyHandler() {		if (isServer) return;		if (isForge				&& getMinecraftVersion() < 170) {			Modchu_Debug.lDebug("initRegisterKeyHandler keyBindingsMap.size()="+keyBindingsMap.size());			if (keyBindingsMap != null					&& keyBindingsMap.size() > 0) {				Object[] keyBindings = Modchu_Reflect.newInstanceArray("KeyBinding", keyBindingsMap.size());				boolean[] repeatings = new boolean[keyBindingsMap.size()];				int i = 0;				for (Entry<Object, Boolean> en : keyBindingsMap.entrySet()) {					Object key = en.getKey();					boolean value = en.getValue();					keyBindings[i] = key;					repeatings[i] = value;					i++;				}				Object handler = Modchu_Reflect.newInstance("modchu.lib.forgeonly.characteristic.Modchu_KeyHandler", new Class[]{ Object[].class, boolean[].class }, new Object[]{ keyBindings, repeatings });				registerKeyHandler(handler);				Modchu_Debug.lDebug("initRegisterKeyHandler registerKeyHandler");			}		}	}	public static void registerKeyHandler(Object handler) {		if (!isServer				&& isForge				&& getMinecraftVersion() < 170); else return;		Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.KeyBindingRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("cpw.mods.fml.client.registry.KeyBindingRegistry$KeyHandler") }, new Object[]{ handler });	}	public static void addLocalization(String s, String s2) {		if (Modchu_Main.isForge) Modchu_Reflect.invokeMethod("LanguageRegistry", "addStringLocalization", new Class[]{ String.class, String.class }, Modchu_Reflect.invokeMethod("LanguageRegistry", "instance"), new Object[]{ s, s2 });		else Modchu_Reflect.invokeMethod("ModLoader", "addLocalization", new Class[]{ String.class, String.class }, new Object[]{ s, s2 });	}	public static void registerGlobalEntityID(Class c, String s, int id, int i, int j) {		Object[] o1 = new Object[]{ c, s, id, i, j };		if (isForge) {			Modchu_Reflect.invokeMethod("EntityRegistry", "registerGlobalEntityID", new Class[]{ Class.class, String.class, int.class, int.class, int.class }, o1);		} else {			Modchu_Reflect.invokeMethod("ModLoader", "registerEntityID", new Class[]{ Class.class, String.class, int.class, int.class, int.class }, o1);		}	}	public static void registerGlobalEntityID(Class c, Class c2, String s, int id, int i, int j) {		Object[] o1 = new Object[]{ c, s, id, i, j };		Object[] o2 = new Object[]{ c2, c2.getName()+".", Modchu_AS.getInt(Modchu_AS.vacancyGlobalEntityID) };		if (isForge) {			Modchu_Reflect.invokeMethod("EntityRegistry", "registerGlobalEntityID", new Class[]{ Class.class, String.class, int.class, int.class, int.class }, o1);			Modchu_Reflect.invokeMethod("EntityRegistry", "registerGlobalEntityID", new Class[]{ Class.class, String.class, int.class }, o2);		} else {			Modchu_Reflect.invokeMethod("ModLoader", "registerEntityID", new Class[]{ Class.class, String.class, int.class, int.class, int.class }, o1);			Modchu_Reflect.invokeMethod("ModLoader", "registerEntityID", new Class[]{ Class.class, String.class, int.class }, o2);		}	}	public static void addSpawn(Class c, int rarity, int minGroupSize, int maxGroupSize, Enum en, Object... biomeGenBase) {		addSpawn(c, null, rarity, minGroupSize, maxGroupSize, en, biomeGenBase);	}	public static void addSpawn(Class c, Class masterClass, int rarity, int minGroupSize, int maxGroupSize, Enum en, Object... biomeGenBase) {		if (c != null); else {			Modchu_Debug.systemLogDebug("Modchu_Main addSpawn c == null !!");			return;		}		if (biomeGenBase != null				&& biomeGenBase.length > 0); else {			biomeGenBase = Modchu_Reflect.newInstanceArray("BiomeGenBase", 3);			biomeGenBase[0] = Modchu_AS.get(Modchu_AS.biomeGenBasePlains);			biomeGenBase[1] = Modchu_AS.get(Modchu_AS.biomeGenBaseOcean);			biomeGenBase[2] = Modchu_AS.get(Modchu_AS.biomeGenBaseDesert);		}		spawnMobMap.put(c, new Object[]{				masterClass != null ? masterClass : c, rarity, minGroupSize, maxGroupSize, en, biomeGenBase		});		Modchu_Debug.mDebug("Modchu_Main addSpawn c="+c+" masterClass="+masterClass);	}	public static void addRecipe(Object itemstack, Object[] objects) {		if (isForge) Modchu_Reflect.invokeMethod("GameRegistry", "addRecipe", new Class[]{ Modchu_Reflect.loadClass("ItemStack"), Object[].class }, new Object[]{ itemstack, (Object[]) objects });		else Modchu_Reflect.invokeMethod("ModLoader", "addRecipe", new Class[]{ Modchu_Reflect.loadClass("ItemStack"), Object[].class }, new Object[]{ itemstack, (Object[]) objects });	}	public static void addRenderer(Class modchu_EntityClass, Class addClass, Object render) {		if (isServer) return;		Class modchu_RenderClass = getModchu_RenderClass(modchu_EntityClass);		Map renderMap = Modchu_CastHelper.Map(Modchu_Reflect.getFieldObject(modchu_RenderClass, "renderMap"));		if (renderMap != null) {			renderMap.put(addClass, render);			Modchu_Reflect.setFieldObject(modchu_RenderClass, "renderMap", renderMap);			//Modchu_Debug.mDebug("addRenderer addClass="+addClass);			//Modchu_Debug.mDebug("addRenderer renderMap.size()="+renderMap.size());		}		Class c = modchu_EntityClass;		Object o = Modchu_Reflect.newInstance(modchu_RenderClass, new Class[]{ float.class }, new Object[]{ 1.0F });		Modchu_Debug.mDebug("addRenderer add c="+c+" o="+o);		boolean flag = getMinecraftVersion() > 164				&& !initLoad;		Modchu_Debug.mDebug("addRenderer add 1 flag="+flag);		if (flag) {			Modchu_Reflect.invokeMethod("RenderingRegistry", "registerEntityRenderingHandler", new Class[]{ Class.class, Modchu_Reflect.loadClass("Render") }, new Object[]{ c, o });		} else {			addRenderer(c, o);		}		c = addClass;		o = render;		Modchu_Debug.mDebug("addRenderer add 2 c="+c+" o="+o);		if (flag) {			Modchu_Reflect.invokeMethod("RenderingRegistry", "registerEntityRenderingHandler", new Class[]{ Class.class, Modchu_Reflect.loadClass("Render") }, new Object[]{ c, o });		} else {			addRenderer(c, o);		}	}	public static void addRenderer(Class c, Object render) {		Map renderMap = getRenderMap();		Modchu_Debug.mDebug("addRenderer (Class Object) renderMap="+renderMap);		if (renderMap != null) renderMap.put(c, render);	}	public static void renderPlayerRendererReplace(Object renderPlayer, String s) {		if (renderPlayer != null); else return;		boolean debug = true;		Map renderMap = getRenderMap();		if (debug) Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 1");		if (renderMap != null); else {			Modchu_Debug.systemLogDebug("Modchu_Main renderPlayerRendererReplace renderMap == null error !!");			return;		}		int version = Modchu_Main.getMinecraftVersion();		Class c = null;		if (!isAether				| (isAether						&& version != 162)) {			if (debug) {				Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 2");				Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 3 renderPlayer="+renderPlayer);			}			Modchu_AS.set(Modchu_AS.renderRenderManager, renderPlayer);			if (Modchu_Main.isForge) {				if (debug) Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 4 Modchu_Main.isForge="+Modchu_Main.isForge);				if (version > 179) {					Map skinMap = Modchu_AS.getMap(Modchu_AS.renderManagerSkinMap);					if (debug) Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 5 renderManagerSkinMap="+skinMap);					if (skinMap != null) skinMap.put(s, renderPlayer);					else {						Modchu_Debug.systemLogDebug("Modchu_Main renderPlayerRendererReplace skinMap == null error !!");					}				}				c = Modchu_Reflect.loadClass("EntityClientPlayerMP");				if (c != null) renderMap.put(c, renderPlayer);				c = Modchu_Reflect.loadClass("EntityOtherPlayerMP");				if (c != null) renderMap.put(c, renderPlayer);				c = Modchu_Reflect.loadClass("EntityPlayer");				if (c != null) renderMap.put(c, renderPlayer);			} else if (isOlddays) {				Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 4 isOlddays");				try {					renderPlayer = (Modchu_RenderPlayer) Modchu_Reflect.newInstance("PFLM_RenderPlayer2", null, null);					Modchu_AS.set(Modchu_AS.renderRenderManager, renderPlayer);					c = Modchu_Reflect.loadClass("EntityClientPlayerMP");					if (c != null) renderMap.put(c, renderPlayer);					c = Modchu_Reflect.loadClass("EntityOtherPlayerMP");					if (c != null) renderMap.put(c, renderPlayer);					c = Modchu_Reflect.loadClass("EntityPlayer");					if (c != null) renderMap.remove(c);				} catch (Exception e) {					e.printStackTrace();				}			} else {				if (debug) {					Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 4 Modchu_Main.isForge="+Modchu_Main.isForge);					Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 5 renderPlayer="+renderPlayer);					Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 6 renderMap="+renderMap);					Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 7 EntityPlayer="+(Modchu_Reflect.loadClass("EntityPlayer")));				}				//map.put(EntityClientPlayerMP.class, renderPlayer);				//map.put(EntityOtherPlayerMP.class, renderPlayer);				c = Modchu_Reflect.loadClass("EntityPlayer");				if (c != null) renderMap.put(c, renderPlayer);			}		} else {			if (debug) Modchu_Debug.lDebug("Modchu_Main renderPlayerRendererReplace 4 isAether renderPlayerInstance="+renderPlayer);			c = Modchu_Reflect.loadClass("EntityPlayer");			if (c != null) renderMap.put(c, renderPlayer);		}	}	public static void addRenderer(Map renderMap) {		if (tempEntityRenderMap != null); else {			Modchu_Debug.lDebug("Modchu_Main addRenderer tempEntityRenderMap == null return.");			return;		}		Modchu_Debug.lDebug("Modchu_Main addRenderer renderMap="+renderMap);		if (renderMap != null				&& !tempEntityRenderMap.isEmpty()); else {			if (renderMap != null); else Modchu_Debug.lDebug("Modchu_Main addRenderer renderMap == null return.");			if (tempEntityRenderMap.isEmpty()) Modchu_Debug.lDebug("Modchu_Main addRenderer tempEntityRenderMap.isEmpty() return.");			return;		}		for (Entry<Class, Object> en : tempEntityRenderMap.entrySet()) {			Class c = en.getKey();			Object o1 = en.getValue();			if (c != null					&& o1 != null) {				Modchu_Debug.lDebug("Modchu_Main addRenderer renderMap.put c="+c+" o1="+o1);				renderMap.put(c, o1);			}		}	}	private static Map getRenderMap() {		Map renderMap = Modchu_AS.get(Modchu_AS.renderManagerInstance) != null ? Modchu_AS.getMap(Modchu_AS.renderManagerEntityRenderMap) : null;		if (renderMap != null); else {			if (tempEntityRenderMap != null); else tempEntityRenderMap = new ConcurrentHashMap();			renderMap = tempEntityRenderMap;		}		return renderMap;	}	public static void registerItem(Object item, String itemName) {		registerItem(item, itemName, null);	}	public static void registerItem(Object item, String itemName, String modId) {		if (isForge) Modchu_Reflect.invokeMethod("GameRegistry", "registerItem", new Class[]{ Modchu_Reflect.loadClass("Item"), String.class, String.class }, new Object[]{ item, itemName, modId });		else Modchu_Reflect.invokeMethod("ModLoader", "addName", new Class[]{ Object.class, String.class }, new Object[]{ item, itemName });	}	public static void languageRegistryAddName(Object item, String itemName) {		if (isForge				&& getMinecraftVersion() < 170) {			Modchu_Reflect.invokeMethod("LanguageRegistry", "addName", new Class[]{ Object.class, String.class }, new Object[]{ item, itemName });		}	}	public static void keyboardEvent(Object keybinding) {		//Modchu_Debug.mDebug("Modchu_Main keyboardEvent");		if (isServer) return;		if (eventKeyBindingList.isEmpty()) {			String s = "keyboardEvent";			if (eventObjectLoadCheckList.contains(s)) return;			eventObjectLoad(getEventObjectList(), getEventObjectLoadCheckList(), s, s, new Class[]{ Object.class }, new Object[]{ new Object[]{ keybinding } });			return;		}		for (Object keyBinding : eventKeyBindingList) {			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent keyBinding="+keyBinding);			Object[] o = eventKeyBindingObjectMap.get(keyBinding);			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent o="+o);			if (o != null					&& o.length > 1); else continue;			Object modInstance = o[0];			boolean b;			if (getMinecraftVersion() > 169) {				b = Modchu_CastHelper.Boolean(o[1]);				b = b						| (!b								&& Modchu_AS.getBoolean(Modchu_AS.keyBindingIsPressed, keyBinding));			} else {				b = keybinding.equals(keyBinding);			}			if (b) {				//Modchu_Debug.mDebug("Modchu_Main keyInput ok. b="+b);				//Modchu_Debug.mDebug("Modchu_Main keyInput ok. keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding));				if (modInstance != null) Modchu_Reflect.invokeMethod(modInstance.getClass(), "keyboardEvent", new Class[]{ Object.class }, modInstance, new Object[]{ keyBinding }, -1);			}		}	}	public static Object event(Object event) {		String s1 = event.getClass().getName();		if (getEventObjectList().isEmpty()				| getEventObjectLoadCheckList().contains(s1)) {			//if (eventObjectList.isEmpty()) Modchu_Debug.mDebug1("Modchu_Main event isEmpty s1="+s1);			//if (eventObjectLoadCheckList.contains(s1)) Modchu_Debug.mDebug1("Modchu_Main event eventObjectLoadCheckList.contains s1="+s1);			return null;		}		String s = s1.replace(".", "");		for (int i = 0; i < s.length() - 1; i++) {			String s2 = s.substring(i, i + 1);			if (s2.equals(s2.toUpperCase())) {				s = s.substring(i);				break;			}		}		s = s.replace("$", "");		String s0 = s.substring(0, 1).toLowerCase();		s = new StringBuilder().append(s0).append(s.substring(1)).toString();		//Modchu_Debug.lDebug1("Modchu_Main event s="+s);		if (s.indexOf("KeyInputEvent") > -1) {			keyboardEvent(event);			return null;		}		if (s.indexOf("tickEvent") > -1) {			if (s.indexOf("ClientTickEvent") > -1) {				return onTickInGame(s1, 0.0F, null, tickByte_ClientTickEvent, event);			}			if (s.indexOf("RenderTickEvent") > -1) {				return onTickInGame(s1, 0.0F, null, tickByte_RenderTickEvent, event);			}			if (s.indexOf("ServerTickEvent") > -1) {				return onTickInGame(s1, 0.0F, null, tickByte_ServerTickEvent, event);			}			if (s.indexOf("WorldTickEvent") > -1) {				return onTickInGame(s1, 0.0F, null, tickByte_WorldTickEvent, event);			}			if (s.indexOf("PlayerTickEvent") > -1) {				return onTickInGame(s1, 0.0F, null, tickByte_PlayerTickEvent, event);			}			return onTickInGame(s1, 0.0F, null, tickByte_OtherTickEvent, event);		}		if (s.indexOf("worldEventLoad") > -1) {			worldEventLoad(event);		}		return eventObjectLoad(getEventObjectList(), getEventObjectLoadCheckList(), s, s1, new Class[]{ Object.class }, new Object[]{ event });	}	public static Object[] eventObjectLoad(ArrayList list, ArrayList list2, String s, String s1, Class[] cla, Object[] oa) {		if (list != null				&& !list.isEmpty()); else {			if (list != null) {				//Modchu_Debug.mDebug("eventObjectLoad list="+list);				//Modchu_Debug.mDebug("eventObjectLoad list.isEmpty()="+list.isEmpty());			} else {				//Modchu_Debug.mDebug("eventObjectLoad list == null !!");			}			return null;		}		int size = list.size();		Object[] o = new Object[size];		boolean b = false;		//Modchu_Debug.mDebug("eventObjectLoad s="+s);		for (int i = 0; i < size ; i++) {			Object modInstance = list.get(i);			if (modInstance != null) {				Method medhod = Modchu_Reflect.getMethod(modInstance.getClass(), s, cla, -1);				if (medhod != null) {					o[i] = Modchu_Reflect.invoke(medhod, modInstance, oa, -1);					b = true;					//Modchu_Debug.mDebug("eventObjectLoad true s="+s);				} else {					//Modchu_Debug.mDebug("eventObjectLoad false modInstance.getClass()="+modInstance.getClass());				}			}		}		if (!b				&& !list2.contains(s1)) {			list2.add(s1);			//Modchu_Debug.mDebug1("eventObjectLoad eventObjectLoadCheckList.add s="+s+" s1="+s1+" size()="+list2.size());		}		return o;	}	public static void worldEventLoad(Object event) {		//Modchu_EntityTameable.worldEventLoad(event);	}	public static boolean modchuLibEvent(String s) {		return !getModchuLibEventObjectLoadCheckList().contains(s);	}	public static Object[] modchuLibEvent(String s, Object[] o) {		//Modchu_Debug.mDebug("modchuLibEvent s="+s);		Object[] o1 = eventObjectLoad(getModchuLibEventObjectList(), getModchuLibEventObjectLoadCheckList(), s, s, new Class[]{ Object[].class }, new Object[]{ o });		if (o1 != null); else return null;		int temp = 0;		int i2 = 0;		boolean flag = false;		for (int i = 0; i < o1.length; i++) {			Object o2 = o1[i];			if (o2 != null					&& o2 instanceof Object[]); else continue;			Object o3 = ((Object[]) o2)[0];			if (o3 instanceof String) {				int i3 = Modchu_CastHelper.Int(o3);				if (temp < i3) {					temp = i3;					i2 = i;					flag = true;				}			}			if (!flag) i2 = i;		}		//Modchu_Debug.mDebug("modchuLibEvent end. return "+(flag ? objectArrayCatting(Modchu_CastHelper.ObjectArray(o1[i2]), 1) : Modchu_CastHelper.ObjectArray(o1[i2])));		return flag ? objectArrayCatting(Modchu_CastHelper.ObjectArray(o1[i2]), 1) : Modchu_CastHelper.ObjectArray(o1[i2]);	}	public static boolean onTickInGame(String s, float f, Object minecraft, byte type, Object... tickData) {		//Modchu_Debug.mDebug("Modchu_Main onTickInGame");		//Modchu_GlStateManager.enableTexture2D();// GL11.glEnable(GL11.GL_TEXTURE_2D);		//GL11.glEnable(GL11.GL_TEXTURE_2D);		//GL11.glDisable(GL11.GL_TEXTURE_2D);		eventObjectLoad(getEventObjectList(), getEventObjectLoadCheckList(), "onTickInGame", s, new Class[]{ byte.class, Object[].class }, new Object[]{ type, (Object[])tickData });		if (type == tickByte_RenderTickEvent				| !isForge) {			if (initModsLoadedStating) {				modsLoaded();				initModsLoadedStating = false;			}			if (Modchu_Debug.debugMessage) Modchu_Debug.dDebugDrow();			// ModsLoadedLoadScreen		}		//isRemote = !isRemote;		//if (!isRemote) return true;		if (!initLoad) setRuntimeException("Modchu_Main initLoad error !! initLoadCount="+initLoadCount);		if (runtimeExceptionFlag) {			String s1 = "";			if (runtimeExceptionStringList != null					&& !runtimeExceptionStringList.isEmpty()) {				for (String s2 : runtimeExceptionStringList) {					Modchu_Debug.systemLogDebug(s2);				}				s1 = runtimeExceptionStringList.get(0);			}			throw new RuntimeException(s1);		}		return true;	}	public static void loadcfg() {		// cfg読み込み		if (cfgdir.exists()) {			if (!mainCfgfile.exists()) {				// cfgファイルが無い = 新規作成				String s[] = {						"debugMessage=true", "debugMessagetexture=false", "debugReflectMessage=true", "debugReflectMessageDetail=false", "versionCheck=true",						"debugLogMessage=false", "careerSave=false", "debugSystemMessage=false"				};				Modchu_Config.writerConfig(mainCfgfile, s);			} else {				// cfgファイルがある				Modchu_Debug.debugMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugMessage", Modchu_Debug.debugMessage));				Modchu_Debug.debugMessagetexture = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugMessagetexture", Modchu_Debug.debugMessagetexture));				Modchu_Reflect.debugReflectMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessage", Modchu_Reflect.debugReflectMessage));				Modchu_Reflect.debugReflectMessageDetail = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessageDetail", Modchu_Reflect.debugReflectMessageDetail));				versionCheck = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "versionCheck", versionCheck));				Modchu_Debug.debugLogMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugLogMessage", Modchu_Debug.debugLogMessage));				Modchu_Debug.careerSave = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "careerSave", Modchu_Debug.careerSave));				Modchu_Debug.debugSystemMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugSystemMessage", Modchu_Debug.debugSystemMessage));				Modchu_Debug.mDebug = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "mDebug", Modchu_Debug.mDebug));				String k[] = {						"debugMessage", "debugMessagetexture", "debugReflectMessage", "debugReflectMessageDetail", "versionCheck",						"debugLogMessage", "careerSave", "debugSystemMessage"				};				String k1[] = {						""+Modchu_Debug.debugMessage, ""+Modchu_Debug.debugMessagetexture, ""+Modchu_Reflect.debugReflectMessage, ""+Modchu_Reflect.debugReflectMessageDetail, ""+versionCheck,						""+Modchu_Debug.debugLogMessage, ""+Modchu_Debug.careerSave, ""+Modchu_Debug.debugSystemMessage				};				Modchu_Config.writerSupplementConfig(mainCfgfile, k, k1);			}		}		initLoadcfg = true;	}	public static void loadModListcfg() {		// cfg読み込み		if (cfgdir.exists()) {			if (!modListCfgfile.exists()) {				return;			} else {				for (Entry<String, String> en : Modchu_Config.loadAllConfig(modListCfgfile).entrySet()) {					String s = en.getKey();					String s1 = en.getValue();					if (s != null							&& s1 != null) {						modEnabledMap.put(s, Modchu_CastHelper.Boolean(""+s1));					}				}			}		}	}	public static void saveModListcfg() {		// cfg書き込み		if (cfgdir.exists()) {			if (!modListCfgfile.exists()) {				// cfgファイルが無い = 新規作成				Modchu_Config.writerConfig(modListCfgfile, modEnabledMap);			} else {				// cfgファイルがある				Modchu_Config.writerSupplementConfig(modListCfgfile, modEnabledMap);			}		}	}	public static BufferedImage loadScreen(Object resourceLocation) {		if (isServer) return null;		BufferedImage bufferedImage = null;		InputStream inputStream = Modchu_RenderEngine.instance.getResourceStream(resourceLocation);		if (inputStream != null); else {			Modchu_Debug.mDebug("Modchu_Main loadScreen() inputStream == null !! return. resourceLocation="+resourceLocation);			return null;		}		try {			bufferedImage = Modchu_RenderEngine.instance.readTextureImage(inputStream);			Modchu_Debug.mDebug("Modchu_Main loadScreen bufferedimage="+bufferedImage);			Modchu_RenderEngine.instance.bindTexture(resourceLocation);		} catch (IOException e) {			e.printStackTrace();		}		if (bufferedImage != null); else {			Modchu_Debug.mDebug("Modchu_Main loadScreen() bufferedImage == null !! return.");			return null;		}		int imageWidth = bufferedImage.getWidth();		int imageHeight = bufferedImage.getHeight();		if (getMinecraftVersion() > 169) {			loadScreen(resourceLocation, imageWidth, imageHeight);		} else {			int[] i0 = getScaledresolutionInts();			try {				loadScreen2(resourceLocation, imageWidth, imageHeight, i0[0], i0[1], i0[2]);			} catch (Exception e) {			}		}		return bufferedImage;	}	public static void loadScreen(Object resourceLocation, int imageWidth, int imageHeight) {		//Modchu_Debug.mDebug("loadScreen");		if (isServer) return;		int width = Modchu_AS.getInt(Modchu_AS.minecraftDisplayWidth);		int height = Modchu_AS.getInt(Modchu_AS.minecraftDisplayHeight);		//Modchu_Debug.mDebug("loadScreen() width="+width);		//Modchu_Debug.mDebug("loadScreen() height="+height);		float scaleX = (float)width / 854F * 2F;		float scaleY = (float)height / 480F * 2F;		if (scaleX < 0.1F) scaleX = 0.1F;		if (scaleY < 0.1F) scaleY = 0.1F;		int depth = 300;		Modchu_GlStateManager.pushMatrix();		Modchu_GlStateManager.ortho(0, width, 0, height, -depth / 2, depth / 2);		loadScreenGLInit();		Modchu_GlStateManager.clearColor(1F, 1F, 1F, 1F);		Modchu_GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);		Modchu_RenderEngine.instance.bindTexture(resourceLocation);		loadScreen(imageWidth, imageHeight, width, height, scaleX, scaleY);		Display.update();		try {			Thread.sleep(1L);		} catch (InterruptedException e) {		}		Modchu_GlStateManager.popMatrix();	}	public static void loadScreenGLInit() {		Modchu_GlStateManager.generateTexture();// GL11.glGenTextures();		Modchu_GlStateManager.enableTexture2D();// GL11.glEnable(GL11.GL_TEXTURE_2D);		Modchu_GlStateManager.enableBlend();		Modchu_GlStateManager.matrixMode(GL11.GL_PROJECTION);		Modchu_GlStateManager.loadIdentity();		Modchu_GlStateManager.matrixMode(GL11.GL_MODELVIEW);		Modchu_GlStateManager.enableDepth();		Modchu_GlStateManager.alphaFunc(GL11.GL_GREATER, 0.7F);	}	public static void loadScreenGLEnd() {/*		Modchu_GlStateManager.enableTexture2D();		Modchu_GlStateManager.shadeModel(7425);		Modchu_GlStateManager.clearDepth(1.0D);		Modchu_GlStateManager.enableDepth();		Modchu_GlStateManager.depthFunc(515);		Modchu_GlStateManager.enableAlpha();		Modchu_GlStateManager.alphaFunc(516, 0.1F);		Modchu_GlStateManager.cullFace(1029);		Modchu_GlStateManager.matrixMode(5889);		Modchu_GlStateManager.loadIdentity();		Modchu_GlStateManager.matrixMode(5888);*//*		if (version > 179) {			Object currentScreen = Modchu_AS.get(Modchu_AS.minecraftCurrentScreen);			Object mc = Modchu_AS.get(Modchu_AS.minecraftGetMinecraft);			if (currentScreen != null) {				Object scaledresolution = Modchu_Reflect.newInstance("ScaledResolution", new Class[]{ version > 172 ? Modchu_Reflect.loadClass("Minecraft") : Modchu_Reflect.loadClass("GameSettings"), int.class, int.class }, new Object[]{ version > 172 ? Modchu_AS.get(Modchu_AS.minecraftGetMinecraft) : Modchu_AS.get(Modchu_AS.minecraftGameSettings), displayWidth, displayHeight });				int scaledWidth = Modchu_AS.getInt(Modchu_AS.scaledresolutionGetScaledWidth, scaledresolution);				int scaledHeight = Modchu_AS.getInt(Modchu_AS.scaledresolutionGetScaledHeight, scaledresolution);				Modchu_AS.set(Modchu_AS.guiScreenFunc_175273_b, currentScreen, mc, scaledWidth, scaledHeight);			}			Modchu_AS.set(Modchu_AS.minecraftLoadingScreen, Modchu_Reflect.newInstance("LoadingScreenRenderer", new Class[]{ Modchu_Reflect.loadClass("Minecraft") }, new Object[]{ mc }));			Modchu_AS.set(Modchu_AS.minecraftUpdateFramebufferSize);		}*/		//Modchu_GlStateManager.clear(0);		//Modchu_GlStateManager.loadIdentity();		//GL11.glEnd();		//GL11.glColor4f(1.0F, 1.0F, 1.0F, 1.0F);		//GL11.glDepthMask(true);		//GL11.glDepthMask(false);		//GL11.glDisable(GL11.GL_CULL_FACE);		//GL11.glEnable(GL11.GL_CULL_FACE);		//GL11.glDisable(GL11.GL_BLEND);		//GL11.glEnable(GL11.GL_BLEND);		//GL11.glDisable(GL11.GL_TEXTURE_2D);		//GL11.glEnable(GL11.GL_TEXTURE_2D);		//GL11.glMatrixMode(GL11.GL_TEXTURE);		//GL11.glLoadIdentity();		//GL11.glMatrixMode(GL11.GL_MODELVIEW);		//GL11.glLoadIdentity();		//Modchu_AS.set(Modchu_AS.openGlHelperSetActiveTexture, Modchu_AS.getInt(Modchu_AS.openGlHelperLightmapTexUnit));		//Modchu_AS.set(Modchu_AS.openGlHelperSetActiveTexture, Modchu_AS.getInt(Modchu_AS.openGlHelperDefaultTexUnit));		//GL11.glDisable(32826);		//GL11.glDisable(GL12.GL_RESCALE_NORMAL);		//Modchu_AS.set(Modchu_AS.openGlHelperSetActiveTexture, Modchu_AS.getInt(Modchu_AS.openGlHelperLightmapTexUnit));		//GL11.glEnable(GL11.GL_TEXTURE_2D);		//Modchu_AS.set(Modchu_AS.openGlHelperSetActiveTexture, Modchu_AS.getInt(Modchu_AS.openGlHelperDefaultTexUnit));		//GL11.glDisable(GL11.GL_LIGHTING);	}	public static void loadScreen(int imageWidth, int imageHeight, int width, int height, float scaleX, float scaleY) {		if (isServer) return;		//Modchu_GlStateManager.pushMatrix();		Modchu_RenderEngine.instance.drawPicture(imageWidth, imageHeight, imageWidth * scaleX, imageHeight * scaleY);		//Modchu_GlStateManager.popMatrix();		//Modchu_Debug.mDebug("Modchu_Main loadScreen() end.");	}	public static void loadScreen3f(int imageWidth, int imageHeight, int width, int height, float z, float scaleX, float scaleY) {		if (isServer) return;		Modchu_RenderEngine.instance.drawPicture3f(imageWidth, imageHeight, imageWidth * scaleX, imageHeight * scaleY, z);		Display.update();		try {			Thread.sleep(1L);		} catch (InterruptedException e) {		}		//Modchu_Debug.mDebug("Modchu_Main loadScreen() end.");	}	private static void loadScreen2(Object resourceLocation, int imageWidth, int imageHeight, int scaledWidth, int scaledHeight, int i) {		//Modchu_Debug.mDebug("Modchu_Main loadScreen2() 1");		if (isServer) return;		String s = null;		int version = getMinecraftVersion();		int displayWidth = Modchu_AS.getInt(Modchu_AS.minecraftDisplayWidth);		int displayHeight = Modchu_AS.getInt(Modchu_AS.minecraftDisplayHeight);		Modchu_GlStateManager.pushMatrix();		Modchu_GlStateManager.generateTexture();//Modchu_GlStateManager.genTextures();		Modchu_GlStateManager.matrixMode(GL11.GL_PROJECTION);		Modchu_GlStateManager.loadIdentity();		Modchu_GlStateManager.ortho(0.0D, (double) scaledWidth, (double) scaledHeight, 0.0D, 1000.0D, 3000.0D);		Modchu_GlStateManager.matrixMode(GL11.GL_MODELVIEW);		Modchu_GlStateManager.loadIdentity();		Modchu_GlStateManager.translate(0.0F, 0.0F, -2000.0F);		Modchu_GlStateManager.disableLighting();		Modchu_GlStateManager.disableFog();		Modchu_GlStateManager.disableDepth();		Modchu_GlStateManager.enableTexture2D();// GL11.glEnable(GL11.GL_TEXTURE_2D);		if (version < 170) Modchu_GlStateManager.viewport(0, 0, displayWidth, displayHeight);		Modchu_GlStateManager.clearColor(1F, 1F, 1F, 1F);		Modchu_GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);		Modchu_GlStateManager.clear(GL11.GL_COLOR_BUFFER_BIT | GL11.GL_DEPTH_BUFFER_BIT);		//Display.update();/*		Modchu_Debug.debugTitle(" ModchuLib Now Loading.1");		try {			Thread.sleep(2000L);		} catch (InterruptedException e) {		}*/		Modchu_AS.set(Modchu_AS.renderEngineBindTexture, resourceLocation);		double x = 0.0D;		double y = 0.0D;		Object tessellator = Modchu_AS.get(Modchu_AS.tessellatorInstance);		Modchu_AS.set(Modchu_AS.tessellatorStartDrawingQuads, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D + x, (double) imageHeight + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) imageWidth + x, (double) imageHeight + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) imageWidth + x, 0.0D + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D + x, 0.0D + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorDraw, tessellator);		//Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		short short1 = 256;		short short2 = 256;		//Display.update();/*		Modchu_Debug.debugTitle(" ModchuLib Now Loading.2");		try {			Thread.sleep(2000L);		} catch (InterruptedException e) {		}*/		scaledTessellator((scaledWidth - short1) / 2, (scaledHeight - short2) / 2, 0, 0, short1, short2);		//Modchu_Debug.mDebug("Modchu_Main loadScreen2() scaledWidth="+scaledWidth);		//Modchu_Debug.mDebug("Modchu_Main loadScreen2() (scaledWidth - short1) / 2="+(scaledWidth - short1) / 2);		if (version < 170) {			Modchu_GlStateManager.disableLighting();			Modchu_GlStateManager.disableFog();			Modchu_GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);			Modchu_GlStateManager.enableAlpha();			Modchu_GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);			//Modchu_Debug.mDebug("Modchu_Main loadScreen2() version < 170 end.");			Modchu_GlStateManager.popMatrix();			return;		}		Display.update();/*		Modchu_Debug.debugTitle(" ModchuLib Now Loading.3");		try {			Thread.sleep(2000L);		} catch (InterruptedException e) {		}*/		Modchu_GlStateManager.disableLighting();		Modchu_GlStateManager.disableFog();		setBackGroundColor(0xffffff);		Modchu_GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);		double d1 = (scaledWidth - short1) / 2D;		//Modchu_Debug.mDebug("Modchu_Main loadScreen2() d1="+d1);		Modchu_AS.set(Modchu_AS.tessellatorStartDrawingQuads, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D, (double) displayHeight, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, d1, (double) displayHeight, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, d1, 0.0D, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D, 0.0D, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorDraw, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_GlStateManager.enableAlpha();		Modchu_GlStateManager.alphaFunc(GL11.GL_GREATER, 0.1F);		//Modchu_GlStateManager.Flush();		//Display.update();/*		Modchu_Debug.debugTitle(" ModchuLib Now Loading.4");		try {			Thread.sleep(2000L);		} catch (InterruptedException e) {		}		Modchu_GlStateManager.Enable(Modchu_GlStateManager.GL_TEXTURE_2D);		Modchu_GlStateManager.ShadeModel(Modchu_GlStateManager.GL_SMOOTH);		Modchu_GlStateManager.ClearDepth(1.0D);		Modchu_GlStateManager.Enable(Modchu_GlStateManager.GL_DEPTH_TEST);		Modchu_GlStateManager.DepthFunc(Modchu_GlStateManager.GL_LEQUAL);		Modchu_GlStateManager.Enable(Modchu_GlStateManager.GL_ALPHA_TEST);		Modchu_GlStateManager.AlphaFunc(Modchu_GlStateManager.GL_GREATER, 0.1F);		Modchu_GlStateManager.CullFace(Modchu_GlStateManager.GL_BACK);		Modchu_GlStateManager.MatrixMode(Modchu_GlStateManager.GL_PROJECTION);		Modchu_GlStateManager.LoadIdentity();		Modchu_GlStateManager.MatrixMode(Modchu_GlStateManager.GL_MODELVIEW);		Modchu_GlStateManager.Viewport(0, 0, displayWidth, displayHeight);		//String s = "Minecraft " + Modchu_Version.getMinecraftVersionString() + " ModchuLib Now Loading.";		//Display.setTitle(s);		Display.update();*//*		Modchu_Debug.debugTitle(" ModchuLib Now Loading. end");		try {			Thread.sleep(50000L);		} catch (InterruptedException e) {		}		s = "Minecraft " + Modchu_Version.getMinecraftVersionString();		Display.setTitle(s);*/		Modchu_GlStateManager.popMatrix();		//Modchu_Debug.mDebug("Modchu_Main loadScreen2() end.");	}	public static Object[] logoModsLoadedLoadScreen(Object resourceLocation) {		if (isServer) return null;		int[] i0 = getScaledresolutionInts();		Object framebuffer = preFramebufferSetting(null, i0[0], i0[1], i0[2]);		//for (int i = 0; i < 2; i++) {		logoModsLoadedLoadScreen_r(resourceLocation, i0[0], i0[1], i0[2]);		//}		return new Object[]{				framebuffer, i0[0], i0[1], i0[2]		};	}	private static int[] getScaledresolutionInts() {		int version = getMinecraftVersion();		int displayWidth = Modchu_AS.getInt(Modchu_AS.minecraftDisplayWidth);		int displayHeight = Modchu_AS.getInt(Modchu_AS.minecraftDisplayHeight);		Object scaledresolution = Modchu_Reflect.newInstance("ScaledResolution", new Class[]{ version > 172 ? Modchu_Reflect.loadClass("Minecraft") : Modchu_Reflect.loadClass("GameSettings"), int.class, int.class }, new Object[]{ version > 172 ? Modchu_AS.get(Modchu_AS.minecraftGetMinecraft) : Modchu_AS.get(Modchu_AS.minecraftGameSettings), displayWidth, displayHeight });		int i = Modchu_AS.getInt(Modchu_AS.scaledresolutionGetScaleFactor, scaledresolution);		int scaledWidth = Modchu_AS.getInt(Modchu_AS.scaledresolutionGetScaledWidth, scaledresolution);		int scaledHeight = Modchu_AS.getInt(Modchu_AS.scaledresolutionGetScaledHeight, scaledresolution);		return new int[]{				scaledWidth, scaledHeight, i		};	}	private static Object preFramebufferSetting(Object framebuffer, int scaledWidth, int scaledHeight, int i) {		if (getMinecraftVersion() > 169) {			if (framebuffer != null); else framebuffer = Modchu_Reflect.newInstance("Framebuffer", new Class[]{ int.class, int.class, boolean.class }, new Object[]{ scaledWidth * i, scaledHeight * i, true });			if (framebuffer != null) Modchu_AS.set(Modchu_AS.framebufferBindFramebuffer, framebuffer, false);		}		return framebuffer;	}	private static void laterFramebufferSetting(Object framebuffer, int scaledWidth, int scaledHeight, int i) {		Modchu_AS.set(Modchu_AS.framebufferUnbindFramebuffer, framebuffer);		Modchu_AS.set(Modchu_AS.framebufferFramebufferRender, framebuffer, scaledWidth * i, scaledHeight * i);	}	private static void logoModsLoadedLoadScreen_r(Object resourceLocation, int scaledWidth, int scaledHeight, int i) {		if (isServer) return;		if (resourceLocation != null); else return;		//Modchu_Debug.mDebug("Modchu_Main logoModsLoadedLoadScreen resourceLocation="+resourceLocation);		if (initModsLoadedLoadScreenFlag) {			//Modchu_Debug.mDebug("Modchu_Main logoModsLoadedLoadScreen initModsLoadedLoadScreenFlag");			try {				tempBufferedImage = Modchu_RenderEngine.instance.readTextureImage(Modchu_RenderEngine.instance.getResourceStream(resourceLocation));				//Modchu_Debug.mDebug("Modchu_Main logoModsLoadedLoadScreen tempBufferedImage="+tempBufferedImage);			} catch (IOException e) {				e.printStackTrace();			}			tempBufferedimageId = drawBufferedImageInit(tempBufferedImage);			//Modchu_Debug.mDebug("Modchu_Main logoModsLoadedLoadScreen tempBufferedimageId="+tempBufferedimageId);			initModsLoadedLoadScreenFlag = false;		}		if (tempBufferedImage != null); else return;		//Modchu_Debug.mDebug1("Modchu_Main logoModsLoadedLoadScreen 1");		try {			loadScreen2(resourceLocation, tempBufferedImage.getWidth(), tempBufferedImage.getHeight(), scaledWidth, scaledHeight, i);			//loadScreenGLEnd();		} catch (Exception e1) {			e1.printStackTrace();		}		//Modchu_Debug.mDebug("Modchu_Main logoModsLoadedLoadScreen end.");	}	private static int drawBufferedImageInit(BufferedImage bufferedimage) {		if (bufferedimage != null) {			if (getMinecraftVersion() > 159) {				return Modchu_AS.getInt(Modchu_AS.textureUtilUploadTextureImage, 1, bufferedimage);			} else {				Modchu_AS.set(Modchu_AS.renderEngineSetupTexture, bufferedimage, 1);			}		}		return -1;	}	private static void drawBufferedImage(BufferedImage bufferedimage, int i, int x, int y, int width, int height, double[] textureRect) {		if (getMinecraftVersion() > 159) {			if (i > -1) Modchu_AS.set(Modchu_AS.textureUtilBindTexture, i);		} else {			if (bufferedimage != null) Modchu_AS.set(Modchu_AS.renderEngineSetupTexture, bufferedimage, 1);		}		renderTexture(x, y, width, height, textureRect);	}	public static Object getModsLoadedLoadScreen() {		return modsLoadedLoadScreen;	}	public static void setModsLoadedLoadScreen(Object resourceLocation) {		modsLoadedLoadScreen = resourceLocation;		initModsLoadedLoadScreenFlag = true;	}	public static boolean isRelease() {		return isRelease;	}	public static Object getHashMapKey(HashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	public static Object getConcurrentHashMapKey(ConcurrentHashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	private static void startVersionCheckThread() {		Modchu_ThreadVersionCheck var0 = new Modchu_ThreadVersionCheck();		var0.start();	}	public static boolean checkRelease(String s) {		if (s != null) {			if (s.length() > 1) {				String ck = s.substring(s.length() - 1, s.length());				String mck = Modchu_Main.getVersion();				String k = version;				mck = k.substring(k.length() - 1);				if (integerCheck(mck)) mck = "";				boolean check = integerCheck(k);				//Modchu_Debug.mDebug("Modchulib checkRelease k="+k+" mck="+mck+" check="+check);				while(!check						&& k.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease k="+k);					check = integerCheck(k.substring(0, k.length() - 1));					k = k.substring(0, k.length() - 1);				}				int m = Modchu_CastHelper.Int(k);				//Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck);				if (integerCheck(ck)) ck = "";				check = integerCheck(s);				while(!check						&& s.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease s="+s);					check = integerCheck(s.substring(0, s.length() - 1));					s = s.substring(0, s.length() - 1);				}				int i = Modchu_CastHelper.Int(s);				Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck+" i="+i+" ck="+ck);				if (i > m) {					return true;				}				if (i == m						&& ck.compareTo(mck) > 0) {					return true;				}				return false;			}		}		return false;	}	public static int integerCheckReturnInt(String s) {		try {			Integer.valueOf(s);			return 1;		} catch (Exception e) {			try {				Long.valueOf(s);				return 2;			} catch (Exception e1) {				return -1;			}		}	}	public static boolean integerCheck(String s) {		try {			Integer.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean floatCheck(String s) {		try {			Float.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean doubleCheck(String s) {		try {			Double.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean byteCheck(String s) {		try {			Byte.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean shortCheck(String s) {		try {			Short.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static int getVersionStringConversionInt(String s) {		if (s != null				&& !s.isEmpty()); else return 0;		int i = 0;		String s1 = s.substring(s.length() - 1);		if (!integerCheck(s1)) {			s = s.substring(0, s.length() - 1);			i = Integer.parseInt(s) * 100 + s1.compareTo("a") + 1;		} else {			i = Integer.parseInt(s) * 100;		}		return i;	}	public static void setNewRelease(String s) {		newRelease = true;		newVersion = s;	}	public static String lastIndexProcessing(String t, String t1) {		int i = t != null				&& !t.isEmpty() ? t.lastIndexOf(t1) : -1;		int i1 = i > -1 ? i + t1.length() : -1;		if (i1 > -1) return t.length() > i1 ? t.substring(i1) : null;		return t;	}	public static String getInsideParentheses(String s) {		return getInsideParentheses(s, 0);	}	public static String getInsideParentheses(String s, int i) {		String s1 = s;		int i1 = 0;		int i2 = 0;		int i3 = 0;		if (i > 0) {			for(int i4 = 0; i4 < i; i4++) {				i1 = s1.indexOf("(");				i2 = s1.indexOf(")");				i3 = s1.indexOf("()");				if (i1 > i2) {					s1 = s1.substring(i2 + 1);				}				else if (i3 > -1) {					s1 = s1.substring(i3 + 2);				} else if (i2 > -1) {					s1 = s1.substring(i2 + 1);				}			};		}		i1 = s1.indexOf("(");		i2 = s1.indexOf(")");		i3 = s1.indexOf("()");		Modchu_Debug.mDebug("getInsideParentheses s1="+s1+" i1="+i1+" i2="+i2+" i3="+i3);		s1 = i1 > -1				&& i2 > -1				&& i3 < 0				&& i1 + 1 < i2				&& 2 < s1.length()				&& i1 + 1 < s1.length()				&& i2 < s1.length() ? s1.substring(i1+1, i2) : null;		return s1;	}	public static HashMap cloneHashMap(HashMap hashMap) {		HashMap map = new HashMap();		Iterator iterator = hashMap.entrySet().iterator();		Entry entry;		Object key;		Object value;		while (iterator.hasNext()) {			entry = (Entry)iterator.next();			key = entry.getKey();			value = entry.getValue();			map.put(key, value);		}		return map;	}	public static int hashMapKeyCount(HashMap hashMap) {		int i = 0;		Iterator iterator = hashMap.entrySet().iterator();		Object entry;		while (iterator.hasNext()) {			entry = iterator.next();			i++;		}		return i;	}	public static ArrayList copyArrayList(ArrayList list) {		ArrayList list2 = new ArrayList();		if (list != null				&& !list.isEmpty()); else return list2;		for (Object o : list) {			list2.add(o);		}		return list2;	}	public static LinkedList copyLinkedList(LinkedList list) {		LinkedList list2 = new LinkedList();		if (list != null				&& !list.isEmpty()); else return list2;		for (Object o : list) {			list2.add(o);		}		return list2;	}	public static int intNormalise(int i, int min, int max) {		return intNormalise(i, min, max, false);	}	public static int intNormalise(int i, int min, int max, boolean b) {		if (i < min) i = b ? max : min;		if (i > max) i = b ? min : max;		return i;	}	public static float floatNormalise(float f, float min, float max) {		return floatNormalise(f, min, max, false);	}	public static float floatNormalise(float f, float min, float max, boolean b) {		if (f < min) f = b ? max : min;		if (f > max) f = b ? min : max;		return f;	}	public static double doubleNormalise(double d, double min, double max) {		return doubleNormalise(d, min, max, false);	}	public static double doubleNormalise(double d, double min, double max, boolean b) {		if (d < min) d = b ? max : min;		if (d > max) d = b ? min : max;		return d;	}	public static Object[] ByteToObjectArray(byte[] by) {		Object[] o = new Object[by.length];		for(int i = 0; i < by.length; i++) {			o[i] = by[i];		}		return o;	}	public static Object[] FloatToObjectArray(float[] fl) {		Object[] o = new Object[fl.length];		for(int i = 0; i < fl.length; i++) {			o[i] = fl[i];		}		return o;	}	public static Object[] DoubleToObjectArray(double[] dou) {		Object[] o = new Object[dou.length];		for(int i = 0; i < dou.length; i++) {			o[i] = dou[i];		}		return o;	}	public static Object[] IntToObjectArray(int[] in) {		Object[] o = new Object[in.length];		for(int i = 0; i < in.length; i++) {			o[i] = in[i];		}		return o;	}	public static Object[] mapKeyToObjectArray(Map map) {		if (map != null); else return null;		Object[] o = new Object[map.size()];		Iterator<Entry> iterator = map.entrySet().iterator();		Entry entry;		int i = 0;		while(iterator.hasNext()) {			entry = iterator.next();			Object key = entry.getKey();			o[i] = key;			i++;		}		return o;	}	public static Object[] listToObjectArray(List list) {		if (list != null); else return null;		Object[] o = new Object[list.size()];		int i = 0;		for (Object value : list) {			o[i] = value;			i++;		}		return o;	}	public static Object[] mapValueToObjectArray(Map map) {		if (map != null); else return null;		Object[] o = new Object[map.size()];		Iterator<Entry> iterator = map.entrySet().iterator();		Entry entry;		int i = 0;		while(iterator.hasNext()) {			entry = iterator.next();			Object value = entry.getValue();			o[i] = value;			i++;		}		return o;	}	public static Object[] integerMapValueToObjectArray(Map<Integer, Object> map) {		if (map != null); else return null;		Object[] o = new Object[map.size()];		LinkedList<Integer> list = new LinkedList();		for (Entry<Integer, Object> en : map.entrySet()) {			list.add(en.getKey());		}		Collections.sort(list);		int i = 0;		for(int i1 : list) {			o[i] = map.get(i1);			i++;		}		return o;	}	public static float[] stringArrayToFloatArray(String[] o) {		float[] f = new float[o.length];		for(int i = 0; i < o.length; i++) {			f[i] = Modchu_CastHelper.Float(o[i]);		}		return f;	}	public static Class[] stringArrayToClassArray(String[] o) {		return Modchu_CastHelper.ClassArray(o);	}	public static Object[] stringArrayToObjectArray(String[] o, Class[] c) {		return Modchu_CastHelper.ObjectArray(o, c);	}	public static float[] objectArrayToFloatArray(Object[] o) {		float[] f = new float[o.length];		for(int i = 0; i < o.length; i++) {			f[i] = Modchu_CastHelper.Float(o[i]);		}		return f;	}	public static double[] stringArrayToDoubleArray(String[] o) {		double[] d = new double[o.length];		for(int i = 0; i < o.length; i++) {			d[i] = Modchu_CastHelper.Float(o[i]);		}		return d;	}	public static double[] objectArrayToDoubleArray(Object[] o) {		double[] d = new double[o.length];		for(int i = 0; i < o.length; i++) {			d[i] = Modchu_CastHelper.Double(o[i]);		}		return d;	}	public static ArrayList objectArrayToArrayList(Object[] o) {		ArrayList list = new ArrayList();		for (Object value : o) {			list.add(value);		}		return list;	}	public static LinkedList objectArrayToLinkedList(Object[] o) {		LinkedList list = new LinkedList();		for (Object value : o) {			list.add(value);		}		return list;	}	public static LinkedList arrayListToLinkedList(ArrayList list) {		LinkedList list2 = new LinkedList();		for (Object value : list) {			list2.add(value);		}		return list2;	}	public static Object[] objectArrayCatting(Object[] o, int i) {		if (i > 0				&& o != null				&& o.length - i > 0); else return o;		Object[] o1 = new Object[o.length - i];		for (int i1 = 0; i1 < o.length - i; i1++) {			o1[i1] = o[i1 + i];		}		return o1;	}	public static Map mapDeepCopy(Map map) {		Map map1 = null;		try {			map1 = (Map) Modchu_Reflect.newInstance(map.getClass());			if (map1 != null); else return map1;			for (Entry<Object, Object> en : ((Map<Object, Object>) map).entrySet()) {				Object key = en.getKey();				Object value = en.getValue();				map1.put(key, value);			}		} catch (Exception e) {			e.printStackTrace();		}		return map1;	}	public static int normalize(int i, int min, int max, int minOver, int maxOver) {		return i < min ? minOver : i > max ? maxOver : i;	}	public static long normalize(long l, long min, long max, long minOver, long maxOver) {		return l < min ? minOver : l > max ? maxOver : l;	}	public static float normalize(float f, float min, float max, float minOver, float maxOver) {		return f < min ? minOver : f > max ? maxOver : f;	}	public static double normalize(double d, double min, double max, double minOver, double maxOver) {		return d < min ? minOver : d > max ? maxOver : d;	}	public static Object getEntityPlayerMainInventoryItemClassToItemStack(Class c, Object entityPlayer) {		Object[] itemStack1 = Modchu_AS.getObjectArray(Modchu_AS.entityPlayerMainInventory, entityPlayer);		if (itemStack1 != null				&& itemStack1.length > 0); else return -1;		for (Object itemStack : itemStack1) {			if (itemStack != null); else continue;			Object item = Modchu_AS.get(Modchu_AS.itemStackGetItem, itemStack);			if (item != null) {				boolean flag = Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_Item").isInstance(item);				if (flag) {					Modchu_IItemMaster item1 = getModchuItem(item);					if (item1 != null							&& c == item1.getClass()) flag = true;				} else if (!c.isInstance(item)) {					flag = false;				}				if (flag) return itemStack;			}		}		return null;	}	public static int getEntityPlayerMainInventoryItemClassToCurrentItem(Class c, Object entityPlayer) {		Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem");		Object[] itemStack1 = Modchu_AS.getObjectArray(Modchu_AS.entityPlayerMainInventory, entityPlayer);		if (itemStack1 != null				&& itemStack1.length > 0); else {			Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem null return. itemStack1="+itemStack1);			return -1;		}		for (int i = 0; i < itemStack1.length; i++) {			Object itemStack = itemStack1[i];			if (itemStack != null); else continue;			Object item = Modchu_AS.get(Modchu_AS.itemStackGetItem, itemStack);			Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem item="+item);			if (item != null) {				boolean flag = Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_Item").isInstance(item);				if (flag) {					Modchu_IItemMaster item1 = getModchuItem(item);					if (item1 != null							&& c == item1.getClass()) flag = true;				} else if (!c.isInstance(item)) {					flag = false;				}				if (flag) {					Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem return i="+i);					return i;				} else {					Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem c else");				}			}		}		Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem end return -1");		return -1;	}	public static Modchu_IItemMaster getModchuItem(Object item) {		if (item instanceof Modchu_Item); else return null;		return ((Modchu_Item) item).master;	}	public static int getMinecraftVersion() {		return Modchu_Main.modchuLibVersion;	}	private static void initModEnabledMap() {		//Modchu_Debug.mDebug("initModEnabledMap");		if (modClassMap != null				&& !modClassMap.isEmpty()) {			for (Entry<String, Class> en : modClassMap.entrySet()) {				String key = en.getKey();				if (isModEnabled(key)						&& !modEnabledMap.containsKey(key)) {					modEnabledMap.put(key, true);				} else {					if (!isModEnabled(key)) Modchu_Debug.mDebug("initModEnabledMap !isModEnabled(key) key="+key);					if (modEnabledMap.containsKey(key)) Modchu_Debug.mDebug("initModEnabledMap modEnabledMap.containsKey(key) key="+key);				}			}		} else {			Modchu_Debug.mDebug("initModEnabledMap modClassMap="+modClassMap);		}	}	public static Class getSpownEntityClass(Object world, double posX, double posY, double posZ) {		Modchu_Debug.mDebug("getSpownEntityClass posX="+posX+" posY="+posY+" posZ="+posZ);		if (!spawnMobMap.isEmpty()) {			Object thePlayer = Modchu_AS.get(Modchu_AS.minecraftThePlayer);			boolean flag = true;			if (thePlayer != null) {				double tempPosX_Min = Modchu_AS.getDouble(Modchu_AS.entityPosX, thePlayer) - 10;				double tempPosX_Max = tempPosX_Min + 20;				double tempPosY_Min = Modchu_AS.getDouble(Modchu_AS.entityPosY, thePlayer) - 5;				double tempPosY_Max = tempPosY_Min + 10;				double tempPosZ_Min = Modchu_AS.getDouble(Modchu_AS.entityPosZ, thePlayer) - 10;				double tempPosZ_Max = tempPosZ_Min + 20;				flag = tempPosX_Min < posX						&& tempPosX_Max > posX						&& tempPosY_Min < posY						&& tempPosY_Max > posY						&& tempPosZ_Min < posZ						&& tempPosZ_Max > posZ;			}			Object biomeGenbase = getMinecraftVersion() > 179 ? Modchu_AS.get(Modchu_AS.worldGetBiomeGenForCoords, world, Modchu_AS.get(Modchu_AS.newBlockPos, posX, posY, posZ)) : Modchu_AS.get(Modchu_AS.worldGetBiomeGenForCoords, world, (int) posX, (int) posZ);			Modchu_Debug.mDebug("getSpownEntityClass biomeGenbase="+biomeGenbase);			ArrayList<Class> list = new ArrayList();			for (Entry<Class, Object[]> en : spawnMobMap.entrySet()) {				Class c = en.getKey();				Object[] o = en.getValue();				Modchu_Debug.mDebug("getSpownEntityClass c="+c);				if (o != null						&& o.length > 5); else continue;				if (flag) {					if (o[0] instanceof Class) {						list.add((Class) o[0]);						Modchu_Debug.mDebug("getSpownEntityClass list.add "+o[0]);					}				}				else if (o[5] != null						&& Array.getLength(o[5]) > 0) {					Object[] biomeGenbaseArray = (Object[]) o[5];					for (Object biomeGenbase2 : biomeGenbaseArray) {						Modchu_Debug.mDebug("getSpownEntityClass biomeGenbase2="+biomeGenbase2);						if (biomeGenbase2.equals(biomeGenbase)) {							if (o[0] instanceof Class) list.add((Class) o[0]);						}					}				}			}			if (list.isEmpty()) {				Modchu_Debug.mDebug("getSpownEntityClass list.isEmpty() flag="+flag);				return null;			}			Collections.shuffle(list);			Modchu_Debug.mDebug("getSpownEntityClass list.get(0)="+list.get(0));			return list.get(0);		}		Modchu_Debug.mDebug("getSpownEntityClass null");		return null;	}	private static void addSpawn() {		if (!spawnMobMap.isEmpty()) {			for (Entry<Class, Object[]> en : spawnMobMap.entrySet()) {				Class c = en.getKey();				Object[] o = en.getValue();				if (o != null						&& o.length > 5); else continue;				Object[] o1 = new Object[]{ c, o[1], o[2], o[3], o[4], o[5] };				if (isForge) Modchu_Reflect.invokeMethod("EntityRegistry", "addSpawn", new Class[]{ Class.class, int.class, int.class, int.class, Modchu_Reflect.loadClass("EnumCreatureType"), Modchu_Reflect.loadClassArray("BiomeGenBase") }, o1);				else Modchu_Reflect.invokeMethod("ModLoader", "addSpawn", new Class[]{ Class.class, int.class, int.class, int.class, Modchu_Reflect.loadClass("EnumCreatureType"), Modchu_Reflect.loadClassArray("BiomeGenBase") }, o1);			}		}	}	private static Class getModchu_RenderClass(Class modchu_EntityClass) {		if (modchu_EntityClass == Modchu_EntityTameable.class) return Modchu_AllRenderLiving.class;		return null;	}	public static boolean forgeEventPost(Object event) {		if (event != null); else return false;		Object EVENT_BUS = Modchu_Reflect.getFieldObject("net.minecraftforge.common.MinecraftForge", "EVENT_BUS");		if (EVENT_BUS != null				&& Modchu_CastHelper.Boolean(Modchu_Reflect.invokeMethod(EVENT_BUS.getClass(), "post", new Class[]{ Modchu_Reflect.loadClass("net.minecraftforge.event.Event") }, EVENT_BUS, new Object[]{ event }))) return true;		return false;	}	public static Object newResourceLocation(String s) {		return getMinecraftVersion() > 159 ? Modchu_Reflect.newInstance("ResourceLocation", new Class[]{ String.class }, new Object[]{ s }) : s;	}	public static ArrayList getEventObjectList() {		return eventObjectList;	}	public static void setEventObjectList(ArrayList list) {		eventObjectList = list;	}	public static ArrayList getModchuLibEventObjectList() {		return modchuLibEventObjectList;	}	public static void setModchuLibEventObjectList(ArrayList list) {		modchuLibEventObjectList = list;	}	public static ArrayList<String> getEventObjectLoadCheckList() {		return eventObjectLoadCheckList;	}	public static void setEventObjectLoadCheckList(ArrayList<String> list) {		eventObjectLoadCheckList = list;	}	public static ArrayList<String> getModchuLibEventObjectLoadCheckList() {		return modchuLibEventObjectLoadCheckList;	}	public static void setModchuLibEventObjectLoadCheckList(ArrayList<String> list) {		modchuLibEventObjectLoadCheckList = list;	}	public static Object getRender(Object entity) {		if (entity != null); else return null;		Object render = Modchu_AS.get(Modchu_AS.render, entity);		if (render != null); else {			render = Modchu_AS.get(Modchu_AS.renderManagerGetEntityRenderObject, entity);		}		return render;	}	public static void scaledTessellator(int p_71392_1_, int p_71392_2_, int p_71392_3_, int p_71392_4_, int p_71392_5_, int p_71392_6_) {		float f = 0.00390625F;		float f1 = 0.00390625F;		Object tessellator = Modchu_AS.get(Modchu_AS.tessellatorInstance);		Modchu_AS.set(Modchu_AS.tessellatorStartDrawingQuads, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (p_71392_1_ + 0), (double) (p_71392_2_ + p_71392_6_), 0.0D, (double) ((float) (p_71392_3_ + 0) * f), (double) ((float) (p_71392_4_ + p_71392_6_) * f1));		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (p_71392_1_ + p_71392_5_), (double) (p_71392_2_ + p_71392_6_), 0.0D, (double) ((float) (p_71392_3_ + p_71392_5_) * f), (double) ((float) (p_71392_4_ + p_71392_6_) * f1));		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (p_71392_1_ + p_71392_5_), (double) (p_71392_2_ + 0), 0.0D, (double) ((float) (p_71392_3_ + p_71392_5_) * f), (double) ((float) (p_71392_4_ + 0) * f1));		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (p_71392_1_ + 0), (double) (p_71392_2_ + 0), 0.0D, (double) ((float) (p_71392_3_ + 0) * f), (double) ((float) (p_71392_4_ + 0) * f1));		Modchu_AS.set(Modchu_AS.tessellatorDraw, tessellator);	}	public static void renderTexture(int x, int y, int width, int height, double[] textureRect) {		if (textureRect != null); else {			Modchu_Debug.mDebug1("Modchu_Main renderTexture textureRect == null !!");			return;		}		Object tessellator = Modchu_AS.get(Modchu_AS.tessellatorInstance);		Modchu_AS.set(Modchu_AS.tessellatorStartDrawingQuads, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (x + 0), (double) (y + 0), 0.0D, textureRect[0], textureRect[1]);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (x + 0), (double) (y + height), 0.0D, textureRect[2], textureRect[3]);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (x + width), (double) (y + height), 0.0D, textureRect[4], textureRect[5]);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (x + width), (double) (y + 0), 0.0D, textureRect[6], textureRect[7]);		Modchu_AS.set(Modchu_AS.tessellatorDraw, tessellator);		Modchu_GlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);	}	public static double[] resetTextureRect(double[] textureRect) {		textureRect[0] = 0.0D;		textureRect[1] = 0.0D;		textureRect[2] = 0.0D;		textureRect[3] = 1.0D;		textureRect[4] = 1.0D;		textureRect[5] = 1.0D;		textureRect[6] = 1.0D;		textureRect[7] = 0.0D;		return textureRect;	}	public static double[] mirrorTexture(double[] textureRect) {		double[] result = new double[8];		result[0] = textureRect[6];		result[1] = textureRect[1];		result[2] = textureRect[4];		result[3] = textureRect[3];		result[4] = textureRect[2];		result[5] = textureRect[5];		result[6] = textureRect[0];		result[7] = textureRect[7];		return result;	}	public static double[] rotateTexture(double[] textureRect) {		double[] result = new double[8];		result[0] = textureRect[2];		result[1] = textureRect[3];		result[2] = textureRect[4];		result[3] = textureRect[5];		result[4] = textureRect[6];		result[5] = textureRect[7];		result[6] = textureRect[0];		result[7] = textureRect[1];		return result;	}	private static void drawSquare(int x, int y, int sizeX, int sizeY, int color) {		Modchu_GlStateManager.pushMatrix();		if (getMinecraftVersion() < 170) {			int displayWidth = Modchu_AS.getInt(Modchu_AS.minecraftDisplayWidth);			int displayHeight = Modchu_AS.getInt(Modchu_AS.minecraftDisplayHeight);			Modchu_GlStateManager.matrixMode(GL11.GL_PROJECTION);			Modchu_GlStateManager.loadIdentity();			Modchu_GlStateManager.ortho(0.0D, (double) displayWidth, (double) displayHeight, 0.0D, 1000.0D, 3000.0D);			Modchu_GlStateManager.matrixMode(GL11.GL_MODELVIEW);			Modchu_GlStateManager.loadIdentity();			Modchu_GlStateManager.translate(0.0F, 0.0F, -2000.0F);		}		setBackGroundColor(color);		Object tessellator = Modchu_AS.get(Modchu_AS.tessellatorInstance);		Modchu_AS.set(Modchu_AS.tessellatorStartDrawingQuads, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D + x, (double) (sizeY + y), 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (sizeX + x), (double) (sizeY + y), 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, (double) (sizeX + x), 0.0D + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorAddVertexWithUV, tessellator, 0.0D + x, 0.0D + y, 0.0D, 0.0D, 0.0D);		Modchu_AS.set(Modchu_AS.tessellatorDraw, tessellator);		Modchu_AS.set(Modchu_AS.tessellatorSetColorOpaque_I, tessellator, 16777215);/*		Modchu_Debug.mDebug("drawSquare");		Display.update();		try {			Thread.sleep(50000L);		} catch (InterruptedException e) {		}*//*		Modchu_GlStateManager.Enable(Modchu_GlStateManager.GL_ALPHA_TEST);		Modchu_GlStateManager.AlphaFunc(Modchu_GlStateManager.GL_GREATER, 0.1F);		Modchu_GlStateManager.Flush();*/		Modchu_GlStateManager.popMatrix();	}	private static final FloatBuffer makeFloatBuffer(float[] arr) {		ByteBuffer bb = ByteBuffer.allocateDirect(arr.length * 4);		bb.order(ByteOrder.nativeOrder());		FloatBuffer fb = bb.asFloatBuffer();		fb.put(arr);		fb.position(0);		return fb;	}	private static void setBackGroundColor(int i) {		if (tempBackGround != null); else tempBackGround = new BufferedImage(2, 2, BufferedImage.TYPE_INT_RGB);		int[] i0 = tempBackGround.getRGB(0, 0, 2, 2, null, 0, 2);		for (int i1 = 0; i1 < i0.length; i1++) {			i0[i1] = i;		}		tempBackGround.setRGB(0, 0, 2, 2, i0, 0, 2);		Modchu_RenderEngine.instance.bindBufferedImage("tempBackGround", tempBackGround);	}	public static long getMillisecond() {		//  現在の時間をミリ秒で返す		return (Sys.getTime() * 1000) / Sys.getTimerResolution();	} 	public static void drawString(String s, int x, int y, int color) {		fontRenderer.drawString(s, x, y, color);	}	public static void mdrawString(String s, int x, int y, int color) {		if (isRelease				&& !Modchu_Debug.mDebug) return;		if (Modchu_Debug.debugFlag(false, s)) fontRenderer.drawString(s, x, y, color);	}	public static float getFontSize() {		return fontRenderer.getFontSize();	}	public static void setFontSize(float f) {		fontRenderer.setFontSize(f);	}	public static int getFontColor() {		return fontColor;	}	public static void resetFontColor() {		setFontColor(0xffffff);	}	public static void setFontColor(int i) {		fontColor = i;	}	public static void setRuntimeException(String s) {		runtimeExceptionFlag = true;		if (runtimeExceptionStringList != null); else runtimeExceptionStringList = new LinkedList();		runtimeExceptionStringList.add(s);	}	public static void resetRuntimeException() {		runtimeExceptionFlag = false;		if (runtimeExceptionStringList != null); else runtimeExceptionStringList = new LinkedList();		runtimeExceptionStringList.clear();	}	public static boolean isVanillaModel(Object model) {		return Modchu_Reflect.loadClass("ModelBase").isInstance(model);	}	public static String getForgeVersionBuildVersionToMcVersion(String s, String s2) {		int i = integerCheck(s) ? Modchu_CastHelper.Int(s) : -1;		if (i > 0) {			int i2 = integerCheck(s2) ? Modchu_CastHelper.Int(s2) : -1;			if (i2 < 30) return "1.1";			if (i2 < 65) return "1.2.3";			if (i2 < 69) return "1.2.4";			if (i2 < 172) return "1.2.5";			if (i2 < 320) return "1.3.2";			if (i2 < 327) return "1.4.0";			if (i2 < 330) return "1.4.1";			if (i2 < 356) return "1.4.2";			if (i2 < 360) return "1.4.3";			if (i2 < 379) return "1.4.4";			if (i2 < 451) return "1.4.5";			if (i2 < 490) return "1.4.6";			if (i2 < 559) return "1.4.7";			if (i2 < 600) return "1.5";			if (i2 < 684) return "1.5.1";			if (i2 < 749) return "1.5.2";			if (i2 < 776) return "1.6.1";			if (i2 < 873) return "1.6.2";			if (i2 < 879) return "1.6.3";			if (i2 < 967) return "1.6.4";			if (i2 < 1150) return "1.7.2";			switch(i) {			case 13:				return "1.7.10";			case 14:				return "1.8";			}		}		return null;	}	public static void itemModelMesherRegister(Object item, int i, String s, String s1) {		//Modchu_Debug.lDebug("itemModelMesherRegister item="+item+" i="+i);		//Modchu_Debug.lDebug("itemModelMesherRegister s="+s+" s1="+s1);		if (getMinecraftVersion() > 179				&& item != null				&& s != null				&& !s.isEmpty()				&& s1 != null				&& !s1.isEmpty()); else {			if (item != null); else Modchu_Debug.systemLogDebug("itemModelMesherRegister error !! item="+item);			if (s != null					&& !s.isEmpty()); else Modchu_Debug.systemLogDebug("itemModelMesherRegister error !! s="+s);			if (s1 != null					&& !s1.isEmpty()); else Modchu_Debug.systemLogDebug("itemModelMesherRegister error !! s1="+s1);			return;		}		Object renderItem = Modchu_AS.get(Modchu_AS.minecraftGetRenderItem);		//Modchu_Debug.lDebug("itemModelMesherRegister renderItem="+renderItem);		if (renderItem != null); else return;		Object itemModelMesher = Modchu_AS.get(Modchu_AS.renderItemGetItemModelMesher, renderItem);		//Modchu_Debug.lDebug("itemModelMesherRegister itemModelMesher="+itemModelMesher);		if (itemModelMesher != null); else return;		Modchu_AS.set(Modchu_AS.itemModelMesherRegister, itemModelMesher, item, i, Modchu_AS.get(Modchu_AS.newModelResourceLocation, s, s1));		//Modchu_Debug.lDebug("itemModelMesherRegister end.");	}}