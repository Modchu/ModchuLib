package modchu.lib;import java.io.File;import java.lang.annotation.Annotation;import java.lang.reflect.Array;import java.lang.reflect.Method;import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.Iterator;import java.util.LinkedList;import java.util.List;import java.util.Map;import java.util.Map.Entry;import java.util.concurrent.ConcurrentHashMap;import modchu.lib.characteristic.Modchu_AS;import modchu.lib.characteristic.Modchu_EntityTameable;import modchu.lib.characteristic.Modchu_Item;import modchu.lib.characteristic.Modchu_RenderLiving;import modchu.lib.characteristic.Modchu_Version;import modchu.lib.characteristic.recompileonly.Modchu_CastHelper;import net.minecraft.src.mod_Modchu_ModchuLib;public class Modchu_Main {	public static final String version = "9a";	//cfg書き込み項目	public static boolean versionCheck = true;	public static final String modName = "ModchuLib";	public static final String versionString = ""+ Modchu_Version.version + "-" + version;	public static ConcurrentHashMap<String, Class> modClassMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Object> modInstanceMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Object, Object[]> eventKeyBindingObjectMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Boolean> modEnabledMap = new ConcurrentHashMap();	public static ConcurrentHashMap<String, Byte> modDisableMap = new ConcurrentHashMap();	public static ConcurrentHashMap<Class, Object[]> spawnMobMap = new ConcurrentHashMap();	public static List<File> modFileList = new ArrayList();	private static ArrayList eventObjectList = new ArrayList();	private static ArrayList eventKeyBindingList = new ArrayList();	private static ArrayList<String> eventObjectLoadCheckList = new ArrayList();	public static Modchu_Main modchu_Main;	public static mod_Modchu_ModchuLib baseModInstance;	public static Class itemRendererClass;	public static Object mc;	public static String newVersion = "";	public static String packageName;	public static String runtimeExceptionString;	private static File cfgdir;	private static File mainCfgfile;	private static File modsDir;	private static File modListCfgfile;	public static final int modchuLibVersion = Modchu_Version.version;	public static int mmmLibVersion;	public static boolean isServer = false;	public static boolean isForge = false;	public static boolean isItemRendererHD = false;	public static boolean isHD = false;	public static boolean newRelease = false;	public static boolean oldRenderItems = false;	public static boolean runtimeExceptionFlag = false;	public static boolean initModsLoadedFlag = false;	public static boolean isRelease = true;	private static boolean isItemRendererDebug = false;	private static boolean packageNameNull = false;	private static boolean isRemote = false;	public static boolean initModsLoaded = false;	public static boolean initLoad = false;	private static int initLoadCount = 0;	private static final int maxInitLoadCount = 15;	public static final byte tickByte_ClientTickEvent = 1;	public static final byte tickByte_RenderTickEvent = 2;	public static final byte tickByte_ServerTickEvent = 3;	public static final byte tickByte_WorldTickEvent = 4;	public static final byte tickByte_PlayerTickEvent = 5;	public static final byte tickByte_OtherTickEvent = 6;	// ~164	private static ConcurrentHashMap<Object, Boolean> keyBindingsMap;	static{		String s = System.getenv("modchu");		if ((s != null				&& s.equals("on"))) {			isRelease = false;		}	}	public Modchu_Main() {		modchu_Main = this;	}	public static String getName() {		return modName;	}	public static String getVersion() {		return versionString;	}	public static void load() {		initLoadCount = 0;		Modchu_AS.instanceCheck();		initLoadCount = 1;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		//対応MOD導入チェック class直チェック		String className1[] = {				"FMLRenderAccessLibrary", "net.minecraft.src.FMLRenderAccessLibrary", "ItemRendererHD"		};		String test2 = null;		for(int n = 0 ; n < className1.length ; n++){			try {				test2 = className1[n];				test2 = ""+Class.forName(test2);				Modchu_Debug.lDebug(test2 + " Check ok.");				if(n == 0						| n == 1) isForge = true;				if(n == 2) isItemRendererHD = true;			} catch (ClassNotFoundException e) {			}		}		initLoadCount = 2;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		if (!isItemRendererHD) {			Modchu_Debug.lDebug("No ItemRendererHD.");		}		if (isItemRendererHD) {			Object b = Modchu_Reflect.getFieldObject("ItemRendererHD", "debug");			if (b != null					&& (Boolean) b) {				isItemRendererDebug = true;			}		}		isHD = isItemRendererHD				&& !isItemRendererDebug;		itemRendererClass = isHD ? Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRendererHD") : Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_ItemRenderer");		initLoadCount = 3;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		if (isForge				&& getMinecraftVersion() < 170) {			if (keyBindingsMap != null) ;else keyBindingsMap = new ConcurrentHashMap();		}		getPackageInit();		Modchu_Reflect.initNameMap();		initLoadCount = 4;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		File mcDataDir = Modchu_AS.getFile(Modchu_AS.minecraftMcDataDir);		cfgdir = new File(mcDataDir, "/config/");		mainCfgfile = new File(cfgdir, ("Modchu_ModchuLib.cfg"));		modListCfgfile = new File(cfgdir, ("Modchu_ModchuLibModList.cfg"));		modsDir = new File(mcDataDir, "/mods/");		initLoadCount = 5;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		loadcfg();		Modchu_Debug.systemDebug("Modchu_Main load", 1);		//Modchu_Debug.lDebug("Modchu_Main load() getPackageInit");		Modchu_Debug.lDebug("Modchu_Main load() mcDataDir.getAbsolutePath()="+mcDataDir.getAbsolutePath());		String s = mcDataDir.getAbsolutePath();		if (s.indexOf("jars") != -1				| new File(s, "gradle").exists()				| new File(new File(s, "../"), "gradle").exists()) {			isRelease = false;		}		initLoadCount = 6;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		//Modchu_Debug.lDebug("Modchu_Main load() new File= "+(new File(new File(s, "../"), "gradle")));		Modchu_Debug.lDebug("Modchu_Main load() isRelease="+isRelease);		mmmLibVersion = -1;		Class MMMLib = Modchu_Reflect.loadClass("mmm.lib.MMMLib");		if (MMMLib != null) {			for (Annotation a : MMMLib.getDeclaredAnnotations()) {				//Modchu_Debug.lDebug("Modchu_Main load() MMMLib Annotation a="+a);				s = a.toString();			}			if (s != null					&& !s.isEmpty()) {				s = getInsideParentheses(s);				//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion s="+s);				if (s != null						&& !s.isEmpty()) {					s = s.replaceAll(" ", "");					String[] s0 = s.split(",");					//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion s0="+s0);					if (s0 != null							&& s0.length > 0) {						for (String s1 : s0) {							if (s1.startsWith("version")) {								//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion version ok.s1="+s1);								int i1 = s1.indexOf("=");								if (i1 > -1) {									s1 = lastIndexProcessing(s1, "=");									i1 = s1.indexOf("-");									if (i1 > -1) {										s = lastIndexProcessing(s1, "-");										//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion version ok.end s="+s);										int i = getVersionStringConversionInt(s);										mmmLibVersion = 1000 + i;									}								}							}						}					}				}			}		} else {			MMMLib = Modchu_Reflect.loadClass("mod_MMM_MMMLib");			if (MMMLib != null) {				s = (String) Modchu_Reflect.getFieldObject(MMMLib, "Revision");				int i = getVersionStringConversionInt(s);				mmmLibVersion = i;			}		}		//Modchu_Debug.lDebug("Modchu_Main load() mmmLibVersion="+mmmLibVersion);		initLoadCount = 7;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		if (Modchu_Debug.debugMessage				&& !Modchu_Main.isRelease()) Modchu_Debug.debugString = new String[10];		Modchu_FileManagerBase.init();		Modchu_FileManager.getModFile(modsDir, modFileList, modClassMap, "modc_");		Modchu_FileManager.addResourcesMod(modchu_Main.getClass(), modClassMap, "modc_");		initLoadCount = 8;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		loadModListcfg();		initLoadCount = 9;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		registerMods();		initLoadCount = 10;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		initModEnabledMap();		initLoadCount = 11;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		saveModListcfg();		initLoadCount = 12;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		addSpawn();		initLoadCount = 13;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		initRegisterKeyHandler();		initLoadCount = 14;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		if (versionCheck) startVersionCheckThread();		initLoadCount = 15;		//Modchu_Debug.lDebug("Modchu_Main load() initLoadCount="+initLoadCount);		initLoad = true;		Modchu_Debug.lDebug("Modchu_Main load() end.");	}	public static boolean isModUse(String key) {		return isModEnabled(key)				&& isModUserEnabled(key);	}	public static void modsLoaded() {		Modchu_Debug.lDebug("Modchu_Main modsLoaded()");		if (initLoadCount != maxInitLoadCount) {			Modchu_Main.runtimeExceptionFlag = true;			Modchu_Main.runtimeExceptionString = "Modchu_Main load() init error !! initLoadCount="+initLoadCount;		}		baseModInstance.loadCheckThread = null;		if (modInstanceMap.isEmpty()) return;		for (Entry<String, Object> en : modInstanceMap.entrySet()) {			Object o = en.getValue();			Class c = o.getClass();			if (getModEnabled(o)) Modchu_Reflect.invokeMethod(c, "modsLoaded", o, -1);		}		initModsLoaded = true;	}	private static void registerMods() {		if (modClassMap != null				&& !modClassMap.isEmpty()) ;else {			Modchu_Debug.Debug("Modchu_Main registerMods() modClassMap.isEmpty()");			return;		}		ArrayList<String> deleteList = new ArrayList();		for (Entry<String, Class> en : modClassMap.entrySet()) {			String key = en.getKey();			Class c = en.getValue();			Method method = Modchu_Reflect.getMethod(c, "load");			boolean deleteFlag = true;			if (method != null) {				Object o = Modchu_Reflect.newInstance(c.getName());				if (o != null) {					if (!modInstanceMap.containsKey(key)) {						modInstanceMap.put(key, o);						if (isModUse(key)) {							Modchu_Reflect.invoke(method, o);							deleteFlag = false;						} else {							Modchu_Debug.mDebug("registerMods getModDisabled c="+c);						}					}				}			}			if (deleteFlag) deleteList.add(key);		}		if (!deleteList.isEmpty()) {			for (String key : deleteList) {				Object o = modInstanceMap.get(key);				boolean b = o != null ? getModEnabled(o) : false;				byte by = (byte) (b ? 2 : 0);				if (!isModUse(key)) by += (byte) 1;				if (!modDisableMap.containsKey(key)) modDisableMap.put(key, by);				modClassMap.remove(key);				modInstanceMap.remove(key);			}		}	}	public static boolean isMod(String s) {		return modInstanceMap.containsKey(s)				| modDisableMap.containsKey(s);	}	public static boolean isModEnabled(String s) {		byte by = getModDisableByte(s);		Object o = modInstanceMap.get(s);		return o != null ? getModEnabled(o) : by >= 2 ? true : false;	}	public static boolean isModUserEnabled(String s) {		byte by = getModDisableByte(s);		return modEnabledMap != null				&& modEnabledMap.containsKey(s) ? modEnabledMap.get(s) : by == 0				| by == 1				| by == 3 ? true : false;	}	private static byte getModDisableByte(String s) {		return modDisableMap != null				&& modDisableMap.containsKey(s) ? modDisableMap.get(s) : 0;	}	public static String getModVersion(String s) {		Object o = modInstanceMap.get(s);		return o != null ? Modchu_CastHelper.String(Modchu_Reflect.invokeMethod(o.getClass(), "getVersion", o, -1)) : null;	}	private static boolean getModEnabled(Object o) {		Object o1 = Modchu_Reflect.invokeMethod(o.getClass(), "modEnabled", o, -1);		//Modchu_Debug.mDebug("getModEnabled c="+o1.getClass());		//Modchu_Debug.mDebug("getModEnabled o1="+o1);		//Modchu_Debug.mDebug("getModEnabled Modchu_CastHelper.Boolean(o1)="+Modchu_CastHelper.Boolean(o1));		return (o1 != null				&& Modchu_CastHelper.Boolean(o1))				| o1 == null;	}	public static void eventRegister(Object o) {		//Modchu_Debug.mDebug("Modchu_Main eventRegister o="+o);		if (!eventObjectList.contains(o)) {			//Modchu_Debug.mDebug("Modchu_Main eventRegister ok.");			eventObjectList.add(o);		}	}	public static void eventUnRegister(Object o) {		if (eventObjectList.contains(o)) eventObjectList.remove(o);	}	public static void registerKey(Object modInstance, Object keyBinding, boolean b) {		//Modchu_Debug.mDebug("Modchu_Main registerKey b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));		if (isServer) return;		if (!isForge) {			Modchu_Reflect.invokeMethod("ModLoader", "registerKey", new Class[]{ Modchu_Reflect.loadClass("BaseMod"), Modchu_Reflect.loadClass("KeyBinding"), boolean.class }, new Object[]{ modInstance, keyBinding, false});		}		else if (isForge) {			if (getMinecraftVersion() > 169) Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.ClientRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("KeyBinding") }, new Object[]{ keyBinding });			if (!eventKeyBindingList.contains(keyBinding)					&& Modchu_Reflect.loadClass("KeyBinding").isInstance(keyBinding)) {				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. b="+b+" keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding)+" keyCategory="+Modchu_AS.get(Modchu_AS.keyBindingKeyCategory, keyBinding));				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. keyBinding="+keyBinding);				eventKeyBindingList.add(keyBinding);				eventKeyBindingObjectMap.put(keyBinding, new Object[]{ modInstance, b });				//Modchu_Debug.mDebug("Modchu_Main registerKey ok. o="+eventKeyBindingObjectMap.get(keyBinding));			}			if (getMinecraftVersion() < 170) {				//Modchu_Debug.mDebug("registerKey keyBinding="+keyBinding);				keyBindingsMap.put(keyBinding, b);			}		}	}	private static void initRegisterKeyHandler() {		if (isForge				&& getMinecraftVersion() < 170) {			Modchu_Debug.mDebug("initRegisterKeyHandler keyBindingsMap.size()="+keyBindingsMap.size());			if (keyBindingsMap != null					&& keyBindingsMap.size() > 0) {				Object[] keyBindings = Modchu_Reflect.newInstanceArray("KeyBinding", keyBindingsMap.size());				boolean[] repeatings = new boolean[keyBindingsMap.size()];				int i = 0;				for (Entry<Object, Boolean> en : keyBindingsMap.entrySet()) {					Object key = en.getKey();					boolean value = en.getValue();					keyBindings[i] = key;					repeatings[i] = value;					i++;				}				Object handler = Modchu_Reflect.newInstance("modchu.lib.fmlonly.Modchu_KeyHandler", new Class[]{ Object[].class, boolean[].class }, new Object[]{ keyBindings, repeatings });				registerKeyHandler(handler);				Modchu_Debug.mDebug("initRegisterKeyHandler registerKeyHandler");			}		}	}	public static void registerKeyHandler(Object handler) {		if (!isServer				&& isForge				&& getMinecraftVersion() < 170) ;else return;		Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.KeyBindingRegistry", "registerKeyBinding", new Class[]{ Modchu_Reflect.loadClass("cpw.mods.fml.client.registry.KeyBindingRegistry$KeyHandler") }, new Object[]{ handler });	}	public static void addLocalization(String s, String s2) {		if (Modchu_Main.isForge) Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.LanguageRegistry", "addStringLocalization", new Class[]{ String.class, String.class }, Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.LanguageRegistry", "instance"), new Object[]{ s, s2 });		else Modchu_Reflect.invokeMethod("ModLoader", "addLocalization", new Class[]{ String.class, String.class }, new Object[]{ s, s2 });	}	public static void registerGlobalEntityID(Class c, Class c2, String s, int id, int i, int j) {		if (isForge) {			Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.EntityRegistry", "registerGlobalEntityID", new Class[]{ Class.class, String.class, int.class, int.class, int.class }, new Object[]{ c, s, id, i, j });			Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.EntityRegistry", "registerGlobalEntityID", new Class[]{ Class.class, String.class, int.class }, new Object[]{ c2, c2.getName()+".", Modchu_AS.getInt(Modchu_AS.vacancyGlobalEntityID) });		}	}	public static void addSpawn(Class c, Class masterClass, int rarity, int minGroupSize, int maxGroupSize, Enum en, Object... biomeGenBase) {		if (isForge) {			if (biomeGenBase != null					&& biomeGenBase.length > 0) ;else {				biomeGenBase = Modchu_Reflect.newInstanceArray("BiomeGenBase", 3);				biomeGenBase[0] = Modchu_AS.get(Modchu_AS.biomeGenBasePlains);				biomeGenBase[1] = Modchu_AS.get(Modchu_AS.biomeGenBaseOcean);				biomeGenBase[2] = Modchu_AS.get(Modchu_AS.biomeGenBaseDesert);			}			spawnMobMap.put(c, new Object[]{					masterClass, rarity, minGroupSize, maxGroupSize, en, biomeGenBase			});			Modchu_Debug.mDebug("Modchu_Main addSpawn c="+c+" masterClass="+masterClass);		}	}	public static void addRecipe(Object itemstack, Object[] objects) {		if (isForge) Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.GameRegistry", "addRecipe", new Class[]{ Modchu_Reflect.loadClass("ItemStack"), Object[].class }, new Object[]{ itemstack, (Object[]) objects });	}	public static void addRenderer(Class modchu_EntityClass, Class addClass, Object render) {		Class modchu_RenderClass = getModchu_RenderClass(modchu_EntityClass);		if (isForge) {			Map renderMap = Modchu_CastHelper.Map(Modchu_Reflect.getFieldObject(modchu_RenderClass, "renderMap"));			if (renderMap != null) {				renderMap.put(addClass, render);				Modchu_Reflect.setFieldObject(modchu_RenderClass, "renderMap", renderMap);				Modchu_Debug.mDebug("addRenderer addClass="+addClass);				Modchu_Debug.mDebug("addRenderer renderMap.size()="+renderMap.size());			}			Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.RenderingRegistry", "registerEntityRenderingHandler", new Class[]{ Class.class, Modchu_Reflect.loadClass("Render") }, new Object[]{ modchu_EntityClass, Modchu_Reflect.newInstance(modchu_RenderClass, new Class[]{ float.class }, new Object[]{ 1.0F }) });			Modchu_Reflect.invokeMethod("cpw.mods.fml.client.registry.RenderingRegistry", "registerEntityRenderingHandler", new Class[]{ Class.class, Modchu_Reflect.loadClass("Render") }, new Object[]{ addClass, render });		}	}	public static void registerItem(Object item, String itemName) {		registerItem(item, itemName, null);	}	public static void registerItem(Object item, String itemName, String modId) {		if (isForge) {			Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.GameRegistry", "registerItem", new Class[]{ Modchu_Reflect.loadClass("Item"), String.class, String.class }, new Object[]{ item, itemName, modId != null					&& !modId.isEmpty() ? modId : "mod_Modchu_ModchuLib" });		}	}	public static void languageRegistryAddName(Object item, String itemName) {		if (isForge				&& getMinecraftVersion() < 170) {			Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.LanguageRegistry", "addName", new Class[]{ Object.class, String.class }, new Object[]{ item, itemName });		}	}	public static void keyboardEvent(Object keybinding) {		//Modchu_Debug.mDebug("Modchu_Main keyboardEvent");		if (eventKeyBindingList.isEmpty()) {			Modchu_Debug.mDebug("Modchu_Main keyboardEvent eventKeyBindingList.isEmpty()");			return;		}		for (Object keyBinding : eventKeyBindingList) {			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent keyBinding="+keyBinding);			Object[] o = eventKeyBindingObjectMap.get(keyBinding);			//Modchu_Debug.mDebug("Modchu_Main keyboardEvent o="+o);			if (o != null					&& o.length > 1) ;else continue;			Object modInstance = o[0];			boolean b;			if (getMinecraftVersion() > 169) {				b = Modchu_CastHelper.Boolean(o[1]);				b = b						| (!b								&& Modchu_AS.getBoolean(Modchu_AS.keyBindingIsPressed, keyBinding));			} else {				b = keybinding.equals(keyBinding);			}			if (b) {				//Modchu_Debug.mDebug("Modchu_Main keyInput ok. b="+b);				//Modchu_Debug.mDebug("Modchu_Main keyInput ok. keyDescription="+Modchu_AS.get(Modchu_AS.keyBindingKeyDescription, keyBinding));				if (modInstance != null) Modchu_Reflect.invokeMethod(modInstance.getClass(), "keyboardEvent", new Class[]{ Object.class }, modInstance, new Object[]{ keyBinding }, -1);			}		}	}	public static void event(Object event) {		String s1 = event.getClass().getName();		if (eventObjectList.isEmpty()				| eventObjectLoadCheckList.contains(s1)) {			//if (eventObjectList.isEmpty()) Modchu_Debug.mDebug1("Modchu_Main event isEmpty s1="+s1);			//if (eventObjectLoadCheckList.contains(s1)) Modchu_Debug.mDebug1("Modchu_Main event eventObjectLoadCheckList.contains s1="+s1);			return;		}		String s = s1.replace(".", "");		for (int i = 0; i < s.length() - 1; i++) {			String s2 = s.substring(i, i + 1);			if (s2.equals(s2.toUpperCase())) {				s = s.substring(i);				break;			}		}		s = s.replace("$", "");		String s0 = s.substring(0, 1).toLowerCase();		s = new StringBuilder().append(s0).append(s.substring(1)).toString();		//Modchu_Debug.mDebug1("Modchu_Main event s="+s);		if (s.indexOf("KeyInputEvent") > -1) {			keyboardEvent(event);			return;		}		if (s.indexOf("tickEvent") > -1) {			if (s.indexOf("ClientTickEvent") > -1) {				onTickInGame(s1, 0.0F, null, tickByte_ClientTickEvent, event);				return;			}			if (s.indexOf("RenderTickEvent") > -1) {				onTickInGame(s1, 0.0F, null, tickByte_RenderTickEvent, event);				return;			}			if (s.indexOf("ServerTickEvent") > -1) {				onTickInGame(s1, 0.0F, null, tickByte_ServerTickEvent, event);				return;			}			if (s.indexOf("WorldTickEvent") > -1) {				onTickInGame(s1, 0.0F, null, tickByte_WorldTickEvent, event);				return;			}			if (s.indexOf("PlayerTickEvent") > -1) {				onTickInGame(s1, 0.0F, null, tickByte_PlayerTickEvent, event);				return;			}			onTickInGame(s1, 0.0F, null, tickByte_OtherTickEvent, event);			return;		}		eventObjectLoad(s, s1, new Class[]{ Object.class }, new Object[]{ event });	}	public static boolean onTickInGame(String s, float f, Object minecraft, byte type, Object... tickData) {		//Modchu_Debug.mDebug("Modchu_Main onTickInGame");		eventObjectLoad("onTickInGame", s, new Class[]{ byte.class, Object[].class }, new Object[]{ type, (Object[])tickData });		//isRemote = !isRemote;		if (Modchu_Debug.debugMessage				&& type == 2				) {			Modchu_Debug.dDebugDrow();		}		//if (!isRemote) return true;		if (!initLoad) {			Modchu_Main.runtimeExceptionFlag = true;			Modchu_Main.runtimeExceptionString = "Modchu_Main initLoad error !! initLoadCount="+initLoadCount;		}		if (runtimeExceptionFlag) throw new RuntimeException(runtimeExceptionString);		return true;	}	public static void eventObjectLoad(String s, String s1, Class[] cla, Object[] oa) {		boolean b = false;		//Modchu_Debug.mDebug("eventObjectLoad s="+s);		for (int i = 0; i < eventObjectList.size() ; i++) {			Object modInstance = eventObjectList.get(i);			if (modInstance != null) {				Method medhod = Modchu_Reflect.getMethod(modInstance.getClass(), s, cla, -1);				if (medhod != null) {					Modchu_Reflect.invoke(medhod, modInstance, oa, -1);					b = true;					//Modchu_Debug.mDebug("eventObjectLoad true s="+s);				} else {					//Modchu_Debug.mDebug("eventObjectLoad false modInstance.getClass()="+modInstance.getClass());				}			}		}		if (!b				&& !eventObjectLoadCheckList.contains(s1)) {			eventObjectLoadCheckList.add(s1);			//Modchu_Debug.mDebug1("eventObjectLoad eventObjectLoadCheckList.add s="+s+" s1="+s1);		}	}	public static void loadcfg() {		// cfg読み込み		if (cfgdir.exists()) {			if (!mainCfgfile.exists()) {				// cfgファイルが無い = 新規作成				String s[] = {						"debugMessage=true", "debugMessagetexture=false", "debugReflectMessage=true", "debugReflectMessageDetail=false", "versionCheck=true",						"debugLogMessage=false", "careerSave=false", "debugSystemMessage=false"				};				Modchu_Config.writerConfig(mainCfgfile, s);			} else {				// cfgファイルがある				Modchu_Debug.debugMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugMessage", Modchu_Debug.debugMessage));				Modchu_Debug.debugMessagetexture = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugMessagetexture", Modchu_Debug.debugMessagetexture));				Modchu_Reflect.debugReflectMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessage", Modchu_Reflect.debugReflectMessage));				Modchu_Reflect.debugReflectMessageDetail = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugReflectMessageDetail", Modchu_Reflect.debugReflectMessageDetail));				versionCheck = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "versionCheck", versionCheck));				Modchu_Debug.debugLogMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugLogMessage", Modchu_Debug.debugLogMessage));				Modchu_Debug.careerSave = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "careerSave", Modchu_Debug.careerSave));				Modchu_Debug.debugSystemMessage = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "debugSystemMessage", Modchu_Debug.debugSystemMessage));				Modchu_Debug.mDebug = Modchu_CastHelper.Boolean(Modchu_Config.loadConfig(mainCfgfile, "mDebug", Modchu_Debug.mDebug));				String k[] = {						"debugMessage", "debugMessagetexture", "debugReflectMessage", "debugReflectMessageDetail", "versionCheck",						"debugLogMessage", "careerSave", "debugSystemMessage"				};				String k1[] = {						""+Modchu_Debug.debugMessage, ""+Modchu_Debug.debugMessagetexture, ""+Modchu_Reflect.debugReflectMessage, ""+Modchu_Reflect.debugReflectMessageDetail, ""+versionCheck,						""+Modchu_Debug.debugLogMessage, ""+Modchu_Debug.careerSave, ""+Modchu_Debug.debugSystemMessage				};				Modchu_Config.writerSupplementConfig(mainCfgfile, k, k1);			}		}	}	public static void loadModListcfg() {		// cfg読み込み		if (cfgdir.exists()) {			if (!modListCfgfile.exists()) {				return;			} else {				for (Entry<String, String> en : Modchu_Config.loadAllConfig(modListCfgfile).entrySet()) {					String s = en.getKey();					String s1 = en.getValue();					if (s != null							&& s1 != null) {						modEnabledMap.put(s, Modchu_CastHelper.Boolean(""+s1));					}				}			}		}	}	public static void saveModListcfg() {		// cfg書き込み		if (cfgdir.exists()) {			if (!modListCfgfile.exists()) {				// cfgファイルが無い = 新規作成				Modchu_Config.writerConfig(modListCfgfile, modEnabledMap);			} else {				// cfgファイルがある				Modchu_Config.writerSupplementConfig(modListCfgfile, modEnabledMap);			}		}	}	public static boolean isRelease() {		return isRelease;	}	public static String getClassName(String s) {/*		if (s == null) return null;		if (s.indexOf(".") > -1) return s;		String s1 = getPackage();		if (s1 != null) return s1.concat(".").concat(s);*/		return s;	}	public static void getPackageInit() {		//if (!isForge) {		Package pack = modchu_Main.getClass().getPackage();		if (pack != null) packageName = pack.getName();		else packageName = null;/*		} else {			packageName = !isRelease ? "net.minecraft.src" : null;		}*/	}	public static String getPackage() {		return packageName;	}	public static Object getHashMapKey(HashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	public static Object getConcurrentHashMapKey(ConcurrentHashMap hashMap, int i) {		if (hashMap.size() < i				| i < 0) return null;		boolean flag = false;		Iterator iterator = hashMap.entrySet().iterator();		int j1 = 0;		do {			if (!iterator.hasNext()) break;			Entry entry = (Entry)iterator.next();			if (j1 == i) return entry.getKey();			j1++;		} while (true);		return null;	}	private static void startVersionCheckThread() {		Modchu_ThreadVersionCheck var0 = new Modchu_ThreadVersionCheck();		var0.start();	}	public static boolean checkRelease(String s) {		if (s != null) {			if (s.length() > 1) {				String ck = s.substring(s.length() - 1, s.length());				String mck = Modchu_Main.getVersion();				String k = version;				mck = k.substring(k.length() - 1);				if (integerCheck(mck)) mck = "";				boolean check = integerCheck(k);				//Modchu_Debug.mDebug("Modchulib checkRelease k="+k+" mck="+mck+" check="+check);				while(!check						&& k.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease k="+k);					check = integerCheck(k.substring(0, k.length() - 1));					k = k.substring(0, k.length() - 1);				}				int m = Modchu_CastHelper.Int(k);				//Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck);				if (integerCheck(ck)) ck = "";				check = integerCheck(s);				while(!check						&& s.length() > 1){					//Modchu_Debug.mDebug("Modchulib checkRelease s="+s);					check = integerCheck(s.substring(0, s.length() - 1));					s = s.substring(0, s.length() - 1);				}				int i = Modchu_CastHelper.Int(s);				Modchu_Debug.mDebug("Modchulib checkRelease m="+m+" mck="+mck+" i="+i+" ck="+ck);				if (i > m) {					return true;				}				if (i == m						&& ck.compareTo(mck) > 0) {					return true;				}				return false;			}		}		return false;	}	public static int integerCheckReturnInt(String s) {		try {			Integer.valueOf(s);			return 1;		} catch (Exception e) {			try {				Long.valueOf(s);				return 2;			} catch (Exception e1) {				return -1;			}		}	}	public static boolean integerCheck(String s) {		try {			Integer.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean floatCheck(String s) {		try {			Float.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean doubleCheck(String s) {		try {			Double.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean byteCheck(String s) {		try {			Byte.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static boolean shortCheck(String s) {		try {			Short.valueOf(s);			return true;		} catch (Exception e) {			return false;		}	}	public static int getVersionStringConversionInt(String s) {		int i = 0;		if (s.length() > 1) {			String s1 = s.substring(s.length() - 1);			s = s.substring(0, s.length() - 1);			i = Integer.parseInt(s) * 100 + s1.compareTo("a") + 1;		} else {			i = Integer.parseInt(s) * 100;		}		return i;	}	public static void setNewRelease(String s) {		newRelease = true;		newVersion = s;	}	public static String lastIndexProcessing(String t, String t1) {		int j = t.lastIndexOf(t1);		if(j > -1) return t.substring(j + 1);		return t;	}	public static String getInsideParentheses(String s) {		return getInsideParentheses(s, 0);	}	public static String getInsideParentheses(String s, int i) {		String s1 = s;		int i1 = 0;		int i2 = 0;		int i3 = 0;		if (i > 0) {			for(int i4 = 0; i4 < i; i4++) {				i1 = s1.indexOf("(");				i2 = s1.indexOf(")");				i3 = s1.indexOf("()");				if (i1 > i2) {					s1 = s1.substring(i2 + 1);				}				else if (i3 > -1) {					s1 = s1.substring(i3 + 2);				} else if (i2 > -1) {					s1 = s1.substring(i2 + 1);				}			};		}		i1 = s1.indexOf("(");		i2 = s1.indexOf(")");		i3 = s1.indexOf("()");		Modchu_Debug.mDebug("getInsideParentheses s1="+s1+" i1="+i1+" i2="+i2+" i3="+i3);		s1 = i1 > -1				&& i2 > -1				&& i3 < 0				&& i1 + 1 < i2				&& 2 < s1.length()				&& i1 + 1 < s1.length()				&& i2 < s1.length() ? s1.substring(i1+1, i2) : null;		return s1;	}	public static HashMap cloneHashMap(HashMap hashMap) {		HashMap map = new HashMap();		Iterator iterator = hashMap.entrySet().iterator();		Entry entry;		Object key;		Object value;		while (iterator.hasNext()) {			entry = (Entry)iterator.next();			key = entry.getKey();			value = entry.getValue();			map.put(key, value);		}		return map;	}	public static int hashMapKeyCount(HashMap hashMap) {		int i = 0;		Iterator iterator = hashMap.entrySet().iterator();		Object entry;		while (iterator.hasNext()) {			entry = iterator.next();			i++;		}		return i;	}	public static ArrayList copyArrayList(ArrayList list) {		ArrayList list2 = new ArrayList();		if (list != null				&& !list.isEmpty()) ;else return list2;		for (Object o : list) {			list2.add(o);		}		return list2;	}	public static LinkedList copyLinkedList(LinkedList list) {		LinkedList list2 = new LinkedList();		if (list != null				&& !list.isEmpty()) ;else return list2;		for (Object o : list) {			list2.add(o);		}		return list2;	}	public static int intNormalise(int i, int min, int max) {		return intNormalise(i, min, max, false);	}	public static int intNormalise(int i, int min, int max, boolean b) {		if (i < min) i = b ? max : min;		if (i > max) i = b ? min : max;		return i;	}	public static float floatNormalise(float f, float min, float max) {		return floatNormalise(f, min, max, false);	}	public static float floatNormalise(float f, float min, float max, boolean b) {		if (f < min) f = b ? max : min;		if (f > max) f = b ? min : max;		return f;	}	public static double doubleNormalise(double d, double min, double max) {		return doubleNormalise(d, min, max, false);	}	public static double doubleNormalise(double d, double min, double max, boolean b) {		if (d < min) d = b ? max : min;		if (d > max) d = b ? min : max;		return d;	}	public static Object[] ByteToObjectArray(byte[] by) {		Object[] o = new Object[by.length];		for(int i = 0; i < by.length; i++) {			o[i] = by[i];		}		return o;	}	public static Object[] FloatToObjectArray(float[] fl) {		Object[] o = new Object[fl.length];		for(int i = 0; i < fl.length; i++) {			o[i] = fl[i];		}		return o;	}	public static Object[] DoubleToObjectArray(double[] dou) {		Object[] o = new Object[dou.length];		for(int i = 0; i < dou.length; i++) {			o[i] = dou[i];		}		return o;	}	public static Object[] IntToObjectArray(int[] in) {		Object[] o = new Object[in.length];		for(int i = 0; i < in.length; i++) {			o[i] = in[i];		}		return o;	}	public static Object[] mapKeyToObjectArray(Map map) {		if (map != null) ;else return null;		Object[] o = new Object[map.size()];		Iterator<Entry> iterator = map.entrySet().iterator();		Entry entry;		int i = 0;		while(iterator.hasNext()) {			entry = iterator.next();			Object key = entry.getKey();			o[i] = key;			i++;		}		return o;	}	public static Object[] listToObjectArray(List list) {		if (list != null) ;else return null;		Object[] o = new Object[list.size()];		int i = 0;		for (Object value : list) {			o[i] = value;			i++;		}		return o;	}	public static Object[] mapValueToObjectArray(Map map) {		if (map != null) ;else return null;		Object[] o = new Object[map.size()];		Iterator<Entry> iterator = map.entrySet().iterator();		Entry entry;		int i = 0;		while(iterator.hasNext()) {			entry = iterator.next();			Object value = entry.getValue();			o[i] = value;			i++;		}		return o;	}	public static Object[] integerMapValueToObjectArray(Map<Integer, Object> map) {		if (map != null) ;else return null;		Object[] o = new Object[map.size()];		LinkedList<Integer> list = new LinkedList();		for (Entry<Integer, Object> en : map.entrySet()) {			list.add(en.getKey());		}		Collections.sort(list);		int i = 0;		for(int i1 : list) {			o[i] = map.get(i1);			i++;		}		return o;	}	public static ArrayList objectArrayToArrayList(Object[] o) {		ArrayList list = new ArrayList();		for (Object value : o) {			list.add(value);		}		return list;	}	public static LinkedList objectArrayToLinkedList(Object[] o) {		LinkedList list = new LinkedList();		for (Object value : o) {			list.add(value);		}		return list;	}	public static Map mapDeepCopy(Map map) {		Map map1 = null;		try {			map1 = (Map) Modchu_Reflect.newInstance(map.getClass());			if (map1 != null) ;else return map1;			for (Entry<Object, Object> en : ((Map<Object, Object>) map).entrySet()) {				Object key = en.getKey();				Object value = en.getValue();				map1.put(key, value);			}		} catch (Exception e) {			e.printStackTrace();		}		return map1;	}	public static Object getEntityPlayerMainInventoryItemClassToItemStack(Class c, Object entityPlayer) {		Object[] itemStack1 = Modchu_AS.getObjectArray(Modchu_AS.entityPlayerMainInventory, entityPlayer);		if (itemStack1 != null				&& itemStack1.length > 0) ;else return -1;		for (Object itemStack : itemStack1) {			if (itemStack != null) ;else continue;			Object item = Modchu_AS.get(Modchu_AS.itemStackGetItem, itemStack);			if (item != null) {				boolean flag = Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_Item").isInstance(item);				if (flag) {					Modchu_IItem item1 = getModchuItem(item);					if (item1 != null							&& c == item1.getClass()) flag = true;				} else if (!c.isInstance(item)) {					flag = false;				}				if (flag) return itemStack;			}		}		return null;	}	public static int getEntityPlayerMainInventoryItemClassToCurrentItem(Class c, Object entityPlayer) {		Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem");		Object[] itemStack1 = Modchu_AS.getObjectArray(Modchu_AS.entityPlayerMainInventory, entityPlayer);		if (itemStack1 != null				&& itemStack1.length > 0) ;else {			Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem null return. itemStack1="+itemStack1);			return -1;		}		for (int i = 0; i < itemStack1.length; i++) {			Object itemStack = itemStack1[i];			if (itemStack != null) ;else continue;			Object item = Modchu_AS.get(Modchu_AS.itemStackGetItem, itemStack);			Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem item="+item);			if (item != null) {				boolean flag = Modchu_Reflect.loadClass("modchu.lib.characteristic.Modchu_Item").isInstance(item);				if (flag) {					Modchu_IItem item1 = getModchuItem(item);					if (item1 != null							&& c == item1.getClass()) flag = true;				} else if (!c.isInstance(item)) {					flag = false;				}				if (flag) {					Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem return i="+i);					return i;				} else {					Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem c else");				}			}		}		Modchu_Debug.mDebug("Modchu_Main getEntityPlayerMainInventoryItemClassToCurrentItem end return -1");		return -1;	}	public static Modchu_IItem getModchuItem(Object item) {		if (item instanceof Modchu_Item) ;else return null;		return ((Modchu_Item) item).master;	}	public static int getMinecraftVersion() {		return Modchu_Main.modchuLibVersion;	}	private static void initModEnabledMap() {		//Modchu_Debug.mDebug("initModEnabledMap");		if (modClassMap != null				&& !modClassMap.isEmpty()) {			for (Entry<String, Class> en : modClassMap.entrySet()) {				String key = en.getKey();				if (isModEnabled(key)						&& !modEnabledMap.containsKey(key)) {					modEnabledMap.put(key, true);				} else {					if (!isModEnabled(key)) Modchu_Debug.mDebug("initModEnabledMap !isModEnabled(key) key="+key);					if (modEnabledMap.containsKey(key)) Modchu_Debug.mDebug("initModEnabledMap modEnabledMap.containsKey(key) key="+key);				}			}		} else {			Modchu_Debug.mDebug("initModEnabledMap modClassMap="+modClassMap);		}	}	public static Class getSpownEntityClass(Object world, double posX, double posY, double posZ) {		Modchu_Debug.mDebug("getSpownEntityClass posX="+posX+" posY="+posY+" posZ="+posZ);		if (!spawnMobMap.isEmpty()) {			Object thePlayer = Modchu_AS.get(Modchu_AS.minecraftThePlayer);			boolean flag = true;			if (thePlayer != null) {				double tempPosX_Min = Modchu_AS.getDouble(Modchu_AS.entityPosX, thePlayer) - 10;				double tempPosX_Max = tempPosX_Min + 20;				double tempPosY_Min = Modchu_AS.getDouble(Modchu_AS.entityPosY, thePlayer) - 5;				double tempPosY_Max = tempPosY_Min + 10;				double tempPosZ_Min = Modchu_AS.getDouble(Modchu_AS.entityPosZ, thePlayer) - 10;				double tempPosZ_Max = tempPosZ_Min + 20;				flag = tempPosX_Min < posX						&& tempPosX_Max > posX						&& tempPosY_Min < posY						&& tempPosY_Max > posY						&& tempPosZ_Min < posZ						&& tempPosZ_Max > posZ;			}			Object biomeGenbase = Modchu_AS.get(Modchu_AS.worldGetBiomeGenForCoords, world, (int) posX, (int) posZ);			Modchu_Debug.mDebug("getSpownEntityClass biomeGenbase="+biomeGenbase);			ArrayList<Class> list = new ArrayList();			for (Entry<Class, Object[]> en : spawnMobMap.entrySet()) {				Class c = en.getKey();				Object[] o = en.getValue();				Modchu_Debug.mDebug("getSpownEntityClass c="+c);				if (o != null						&& o.length > 5) ;else continue;				if (flag) {					if (o[0] instanceof Class) {						list.add((Class) o[0]);						Modchu_Debug.mDebug("getSpownEntityClass list.add "+o[0]);					}				}				else if (o[5] != null						&& Array.getLength(o[5]) > 0) {					Object[] biomeGenbaseArray = (Object[]) o[5];					for (Object biomeGenbase2 : biomeGenbaseArray) {						Modchu_Debug.mDebug("getSpownEntityClass biomeGenbase2="+biomeGenbase2);						if (biomeGenbase2.equals(biomeGenbase)) {							if (o[0] instanceof Class) list.add((Class) o[0]);						}					}				}			}			if (list.isEmpty()) {				Modchu_Debug.mDebug("getSpownEntityClass list.isEmpty() flag="+flag);				return null;			}			Collections.shuffle(list);			Modchu_Debug.mDebug("getSpownEntityClass list.get(0)="+list.get(0));			return list.get(0);		}		Modchu_Debug.mDebug("getSpownEntityClass null");		return null;	}	private static void addSpawn() {		if (isForge) {			if (!spawnMobMap.isEmpty()) {				for (Entry<Class, Object[]> en : spawnMobMap.entrySet()) {					Class c = en.getKey();					Object[] o = en.getValue();					if (o != null							&& o.length > 5) ;else continue;					Modchu_Reflect.invokeMethod("cpw.mods.fml.common.registry.EntityRegistry", "addSpawn", new Class[]{ Class.class, int.class, int.class, int.class, Modchu_Reflect.loadClass("EnumCreatureType"), Modchu_Reflect.loadClassArray("BiomeGenBase") }, new Object[]{ c, o[1], o[2], o[3], o[4], o[5] });				}			}		}	}	private static Class getModchu_RenderClass(Class modchu_EntityClass) {		if (modchu_EntityClass == Modchu_EntityTameable.class) return Modchu_RenderLiving.class;		return null;	}	public static boolean forgeEventPost(Object event) {		if (event != null) ;else return false;		Object EVENT_BUS = Modchu_Reflect.getFieldObject("net.minecraftforge.common.MinecraftForge", "EVENT_BUS");		if (EVENT_BUS != null				&& Modchu_CastHelper.Boolean(Modchu_Reflect.invokeMethod(EVENT_BUS.getClass(), "post", new Class[]{ Modchu_Reflect.loadClass("net.minecraftforge.event.Event") }, EVENT_BUS, new Object[]{ event }))) return true;		return false;	}}